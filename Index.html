<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Liverpool Rummy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1A237E">
    <title>Liverpool Rummy</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        :root {
            --primary: #FF5722;
            --primary-dark: #E64A19;
            --success: #4CAF50;
            --danger: #F44336;
            --warning: #FFC107;
            --bg: #1A237E;
            --card-bg: #283593;
            --card-hover: #3949AB;
            --text: #FFFFFF;
            --text-muted: #B3E5FC;
            --hearts: #F44336;
            --diamonds: #0b375b;
            --clubs: #4CAF50;
            --spades: #212121;
            --wild: #9C27B0;
            --radius: 20px;
            --yellow-card: #FFEB3B;
            --green-card: #4CAF50;
            --blue-card: #2196F3;
            --red-card: #F44336;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Poppins', sans-serif;
            background: linear-gradient(135deg, var(--bg), #0D47A1);
            min-height: 100vh;
            color: var(--text);
            overflow-x: hidden;
        }

        .screen { display: none; min-height: 100vh; padding: 20px; animation: fadeIn 0.3s ease; }
        .screen.active { display: flex; flex-direction: column; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        .container { max-width: 500px; width: 100%; margin: 0 auto; }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 10px;
            padding: 18px 32px; font-family: inherit; font-size: 1.1rem; font-weight: 700;
            border: none; border-radius: var(--radius); cursor: pointer; transition: all 0.2s; width: 100%;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; box-shadow: 0 6px 20px rgba(255,87,34,0.5); }
        .btn-primary:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 8px 25px rgba(255,87,34,0.6); }
        .btn-success { background: linear-gradient(135deg, var(--success), #388E3C); color: white; box-shadow: 0 4px 15px rgba(76,175,80,0.4); }
        .btn-danger { background: linear-gradient(135deg, var(--danger), #C62828); color: white; box-shadow: 0 4px 15px rgba(244,67,54,0.4); }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 3px solid var(--warning); }
        .btn-secondary:hover { background: var(--card-hover); transform: scale(1.02); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .btn-sm { padding: 12px 20px; font-size: 0.95rem; }

        /* Title Screen */
        #title-screen { justify-content: center; align-items: center; text-align: center; background: linear-gradient(180deg, var(--bg), #0D47A1); }
        .logo { margin-bottom: 60px; animation: logoFloat 3s ease-in-out infinite; }
        @keyframes logoFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .logo h1 { font-size: clamp(3rem, 12vw, 5rem); font-weight: 900; background: linear-gradient(135deg, #F44336, #FF9800, #FFEB3B, #4CAF50, #2196F3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: none; letter-spacing: -2px; }
        .logo p { color: var(--warning); font-size: 1.2rem; font-weight: 700; text-transform: uppercase; letter-spacing: 3px; margin-top: 10px; }
        .menu-buttons { display: flex; flex-direction: column; gap: 16px; width: 100%; max-width: 320px; }

        /* Setup Screens */
        .setup-screen { justify-content: flex-start; padding-top: 60px; }
        .back-btn { position: absolute; top: 20px; left: 20px; background: var(--card-bg); border: none; color: var(--text); width: 48px; height: 48px; border-radius: 50%; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .back-btn:hover { background: var(--card-hover); }
        .setup-title { font-size: 1.8rem; font-weight: 700; text-align: center; margin-bottom: 40px; }
        .form-group { margin-bottom: 24px; }
        .form-label { display: block; font-size: 0.95rem; font-weight: 600; color: var(--text-muted); margin-bottom: 10px; }
        .form-input { width: 100%; padding: 16px 20px; font-family: inherit; font-size: 1.1rem; background: var(--card-bg); border: 2px solid var(--card-hover); border-radius: var(--radius); color: var(--text); }
        .form-input:focus { outline: none; border-color: var(--primary); }
        .form-input::placeholder { color: var(--text-muted); }

        .option-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 10px; }
        .option-btn { padding: 16px; font-family: inherit; font-size: 1.2rem; font-weight: 700; background: var(--card-bg); border: 3px solid var(--card-hover); border-radius: var(--radius); color: var(--text); cursor: pointer; transition: all 0.2s; }
        .option-btn:hover { border-color: var(--primary); }
        .option-btn.selected { background: var(--primary); border-color: var(--primary); transform: scale(1.05); }

        .diff-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .diff-btn { padding: 14px; font-family: inherit; font-size: 0.95rem; font-weight: 600; background: var(--card-bg); border: 3px solid var(--card-hover); border-radius: var(--radius); color: var(--text); cursor: pointer; }
        .diff-btn.selected.easy { background: var(--success); border-color: var(--success); }
        .diff-btn.selected.medium { background: var(--warning); border-color: var(--warning); color: #000; }
        .diff-btn.selected.hard { background: var(--danger); border-color: var(--danger); }

        /* Game Mode Cards */
        .mode-cards { display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 0 auto; }
        .mode-card { background: linear-gradient(135deg, var(--card-bg), #1565C0); border: 3px solid var(--card-hover); border-radius: var(--radius); padding: 25px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .mode-card:hover { border-color: var(--warning); transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .mode-card:active { transform: translateY(-2px); }
        .mode-icon { font-size: 3rem; margin-bottom: 10px; }
        .mode-title { font-size: 1.5rem; font-weight: 800; color: var(--warning); margin-bottom: 5px; }
        .mode-desc { font-size: 1rem; color: var(--text); margin-bottom: 10px; }
        .mode-contracts { font-size: 0.8rem; color: var(--text-muted); padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; }

        /* Lobby */
        .room-code-box { background: var(--card-bg); border-radius: var(--radius); padding: 30px; text-align: center; margin-bottom: 30px; }
        .room-code-label { font-size: 0.95rem; color: var(--text-muted); margin-bottom: 10px; }
        .room-code { font-size: 3rem; font-weight: 800; letter-spacing: 0.3em; color: var(--warning); }
        .players-list { background: var(--card-bg); border-radius: var(--radius); padding: 20px; margin-bottom: 20px; }
        .players-list-title { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 15px; font-weight: 600; }
        .player-row { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg); border-radius: 10px; margin-bottom: 8px; }
        .player-row:last-child { margin-bottom: 0; }
        .player-name { font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 20px; font-weight: 700; }
        .badge-host { background: var(--warning); color: #000; }
        .badge-cpu { background: var(--wild); color: #fff; }
        .badge-you { background: var(--primary); color: #fff; }
        .remove-btn { background: var(--danger); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 1rem; }

        /* Game Screen */
        #game-screen { padding: 10px; background: linear-gradient(180deg, var(--bg), #0D47A1); }
        .game-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: linear-gradient(135deg, var(--card-bg), #1565C0); border-radius: var(--radius); margin-bottom: 12px; border: 2px solid var(--warning); }
        .contract-info { text-align: left; }
        .contract-num { font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .contract-desc { font-size: 1.2rem; font-weight: 800; color: var(--warning); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        .game-stats { text-align: right; font-size: 0.9rem; color: var(--text-muted); }
        .game-stats div { margin-bottom: 2px; }

        .turn-indicator { text-align: center; padding: 18px; background: var(--card-bg); border-radius: var(--radius); margin-bottom: 12px; font-weight: 700; font-size: 1.1rem; border: 3px solid transparent; }
        .turn-indicator.your-turn { background: linear-gradient(135deg, var(--success), #2E7D32); color: white; animation: turnPulse 1.5s infinite; border-color: #81C784; }
        .turn-indicator.waiting { color: var(--text-muted); background: var(--card-bg); }
        @keyframes turnPulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(76,175,80,0.6); transform: scale(1); } 50% { box-shadow: 0 0 20px 5px rgba(76,175,80,0.3); transform: scale(1.02); } }

        .opponents-row { display: flex; gap: 12px; overflow-x: auto; padding: 12px 5px; margin-bottom: 12px; justify-content: center; flex-wrap: wrap; }
        .opponent-card { flex-shrink: 0; background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 15px 20px; min-width: 120px; text-align: center; border: 3px solid transparent; transition: all 0.3s ease; }
        .opponent-card.active { border-color: var(--warning); box-shadow: 0 0 20px rgba(255,193,7,0.4); animation: activeGlow 1s infinite; }
        @keyframes activeGlow { 0%, 100% { box-shadow: 0 0 15px rgba(255,193,7,0.4); } 50% { box-shadow: 0 0 30px rgba(255,193,7,0.6); } }
        .opponent-name { font-weight: 700; font-size: 0.9rem; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .opponent-cards { font-size: 2rem; font-weight: 900; color: var(--warning); text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .opponent-status { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }
        .laid-badge { font-size: 0.7rem; background: linear-gradient(135deg, var(--success), #2E7D32); color: white; padding: 4px 10px; border-radius: 12px; margin-top: 6px; display: inline-block; font-weight: 700; }

        .table-area { display: flex; justify-content: center; gap: 50px; padding: 25px; margin-bottom: 10px; }
        .pile { text-align: center; }
        .pile-label { font-size: 0.9rem; color: var(--warning); margin-bottom: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .pile-cards { position: relative; width: 85px; height: 120px; }

        .card { width: 85px; height: 120px; border-radius: 16px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 800; cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); user-select: none; position: relative; overflow: hidden; }
        .card-back { background: linear-gradient(135deg, #FF5722, #E64A19); border: 4px solid rgba(255,255,255,0.3); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .card-back::before { content: ''; position: absolute; inset: 8px; border: 3px solid rgba(255,255,255,0.2); border-radius: 10px; }
        .card-back::after { content: 'üé¥'; font-size: 2.5rem; opacity: 0.5; }
        .card-front { background: white; border: 4px solid #333; color: #333; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .card-front.hearts { background: linear-gradient(180deg, #fff 0%, #ffe0e0 100%); color: #D32F2F; border-color: #D32F2F; }
        .card-front.diamonds { background: linear-gradient(180deg, #fff 0%, #e0e8ff 100%); color: #1976D2; border-color: #1976D2; }
        .card-front.clubs { background: linear-gradient(180deg, #fff 0%, #e0ffe0 100%); color: #388E3C; border-color: #388E3C; }
        .card-front.spades { background: linear-gradient(180deg, #fff 0%, #e0e0e0 100%); color: #212121; border-color: #212121; }
        .card-front.wild { background: linear-gradient(135deg, #9C27B0, #7B1FA2, #E91E63); color: white; border-color: #FFD700; animation: wildPulse 2s ease-in-out infinite; }
        @keyframes wildPulse { 0%, 100% { box-shadow: 0 0 10px #9C27B0; } 50% { box-shadow: 0 0 25px #E91E63, 0 0 35px #9C27B0; } }
        
        /* Custom Joker Card */
        .card-front.joker-custom { 
            background-size: cover; 
            background-position: center top;
            border: 4px solid #FFD700; 
        }
        .card-front.joker-custom .card-rank { 
            font-size: 2.5rem; 
            color: white; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), -2px -2px 4px rgba(0,0,0,0.9); 
            z-index: 2;
        }
        .card-front.joker-custom .card-suit { display: none; }
        
        /* Custom Queen Card */
        .card-front.queen-custom { 
            background-size: cover; 
            background-position: center top;
            border: 4px solid gold; 
        }
        .card-front.queen-custom .card-rank { 
            font-size: 2.5rem; 
            color: white; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), -2px -2px 4px rgba(0,0,0,0.9); 
            z-index: 2;
        }
        .card-front.queen-custom .card-suit { 
            font-size: 1.4rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            z-index: 2;
        }
        
        .card-rank { font-size: 1.8rem; line-height: 1; font-weight: 900; }
        .card-suit { font-size: 2rem; line-height: 1; }
        .card:hover:not(.card-back) { transform: translateY(-8px) scale(1.05); box-shadow: 0 15px 30px rgba(0,0,0,0.3); }
        .card.selected { transform: translateY(-25px) scale(1.1); box-shadow: 0 20px 40px rgba(255,87,34,0.5); border-color: var(--warning) !important; animation: selectedBounce 0.5s ease; }
        @keyframes selectedBounce { 0% { transform: translateY(0) scale(1); } 50% { transform: translateY(-30px) scale(1.15); } 100% { transform: translateY(-25px) scale(1.1); } }
        .deck-pile .card-back:hover { transform: scale(1.08) rotate(-2deg); }
        .deck-count { position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%); font-size: 0.85rem; color: var(--warning); font-weight: 700; }
        
        .melds-area { background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 18px; margin-bottom: 12px; min-height: 60px; border: 2px solid rgba(255,255,255,0.1); }
        .melds-title { font-size: 0.9rem; color: var(--warning); margin-bottom: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .melds-container { display: flex; flex-wrap: wrap; gap: 18px; justify-content: center; }
        .meld-group { background: rgba(0,0,0,0.2); border-radius: 14px; padding: 12px; border: 2px solid rgba(255,255,255,0.1); }
        .meld-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 8px; font-weight: 600; }
        .meld-cards { display: flex; }
        .meld-cards .card { width: 50px; height: 72px; margin-left: -15px; font-size: 0.85rem; border-width: 3px; }
        .meld-cards .card:first-child { margin-left: 0; }
        .meld-cards .card-rank { font-size: 1.1rem; }
        .meld-cards .card-suit { font-size: 1.2rem; }

        .hand-area { background: linear-gradient(180deg, var(--card-bg), #0D47A1); border-radius: var(--radius) var(--radius) 0 0; padding: 18px; margin: 0 -10px -10px; border-top: 3px solid var(--warning); }
        .hand-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .hand-title { font-weight: 700; font-size: 1.1rem; color: var(--warning); }
        .hand-controls { display: flex; gap: 8px; }
        .sort-btn { background: rgba(255,255,255,0.1); border: 2px solid var(--warning); color: var(--warning); padding: 8px 14px; border-radius: 10px; font-size: 0.85rem; cursor: pointer; font-family: inherit; font-weight: 700; transition: all 0.2s; }
        .sort-btn:hover { background: var(--warning); color: #000; }
        .sort-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .hand-cards { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 12px 0; min-height: 140px; position: relative; }
        
        /* Drag and drop */
        .card.dragging { opacity: 0.5; transform: scale(1.1); z-index: 100; }
        .card.drag-over { border: 3px dashed var(--warning) !important; }

        /* Dead card full overlay */
        .card-dead-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            border-radius: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            z-index: 10;
            color: #fff;
            animation: skullPop 0.25s ease;
        }
        .meld-cards .card-dead-overlay {
            font-size: 1.5rem;
        }
        @keyframes skullPop {
            0% { transform: scale(0.6); opacity: 0; }
            60% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .card.dead-card {
            opacity: 0.7;
            cursor: not-allowed !important;
        }
        .card.dead-card:hover {
            transform: none !important;
        }
        /* Global motion polish */
        body {
            background-size: 300% 300%;
            animation: bgShift 18s ease infinite;
        }
        @keyframes bgShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .btn:active { transform: translateY(1px) scale(0.99); }
        .mode-card { animation: cardFloat 8s ease-in-out infinite; }
        .pile .card { animation: cardFloat 7s ease-in-out infinite; }
        .card-appear { animation: cardAppear 0.28s ease; }
        .card:hover:not(.card-back) { animation: cardHover 0.4s ease; }
        @keyframes cardAppear {
            0% { transform: translateY(12px) scale(0.96); opacity: 0; }
            70% { transform: translateY(-4px) scale(1.04); opacity: 1; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        @keyframes cardFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        @keyframes cardHover {
            0% { box-shadow: 0 0 0 rgba(0,0,0,0); }
            100% { box-shadow: 0 15px 30px rgba(0,0,0,0.3); }
        }

        .action-bar { display: flex; gap: 12px; margin-top: 18px; }
        .action-btn { flex: 1; padding: 16px; font-family: inherit; font-size: 1rem; font-weight: 800; border: none; border-radius: 14px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; }
        .action-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none !important; }
        .action-btn:not(:disabled):hover { transform: translateY(-3px); }
        .btn-laydown { background: linear-gradient(135deg, var(--success), #2E7D32); color: white; box-shadow: 0 4px 15px rgba(76,175,80,0.4); }
        .btn-addto { background: linear-gradient(135deg, #2196F3, #1565C0); color: white; box-shadow: 0 4px 15px rgba(33,150,243,0.4); }
        .btn-discard { background: linear-gradient(135deg, var(--danger), #C62828); color: white; box-shadow: 0 4px 15px rgba(244,67,54,0.4); }

        /* Modal */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1000; align-items: center; justify-content: center; padding: 20px; }
        .modal-overlay.active { display: flex; animation: modalFadeIn 0.3s ease; }
        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal { background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 30px; max-width: 420px; width: 100%; max-height: 80vh; overflow-y: auto; border: 3px solid var(--warning); animation: modalSlideIn 0.3s ease; }
        @keyframes modalSlideIn { from { transform: scale(0.8) translateY(20px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
        .modal-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 20px; text-align: center; color: var(--warning); }
        .modal-body { margin-bottom: 25px; }
        .modal-buttons { display: flex; flex-direction: column; gap: 10px; }
        .buy-card-display { display: flex; justify-content: center; margin: 20px 0; }
        .buy-card-display .card { width: 90px; height: 130px; }
        .buy-card-display .card-rank { font-size: 1.8rem; }
        .buy-card-display .card-suit { font-size: 2rem; }
        .buy-info { text-align: center; color: var(--text-muted); font-size: 0.95rem; }
        .meld-option { background: var(--bg); border: 2px solid var(--card-hover); border-radius: 10px; padding: 15px; margin-bottom: 10px; cursor: pointer; }
        .meld-option:hover { border-color: var(--primary); }
        .meld-option.disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        .meld-option-title { font-weight: 600; margin-bottom: 5px; }
        .meld-option-cards { font-size: 0.9rem; color: var(--text-muted); }

        /* Buy Banner - shows at top instead of blocking modal */
        .buy-banner { display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, var(--warning), #D97706); padding: 20px; z-index: 500; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .buy-banner.active { display: block; animation: slideDown 0.3s ease; }
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        .buy-banner-content { max-width: 500px; margin: 0 auto; }
        .buy-banner-top { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .buy-banner-card { width: 60px; height: 85px; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: white; border: 3px solid #ccc; font-weight: 700; font-size: 1.1rem; flex-shrink: 0; }
        .buy-banner-card.hearts, .buy-banner-card.diamonds { color: var(--hearts); }
        .buy-banner-card.clubs, .buy-banner-card.spades { color: #1a1a1a; }
        .buy-banner-card.wild { background: linear-gradient(135deg, var(--wild), #7C3AED); color: white; border-color: var(--wild); }
        .buy-banner-text { color: #000; text-align: center; }
        .buy-banner-title { font-weight: 800; font-size: 1.2rem; margin-bottom: 4px; }
        .buy-banner-subtitle { font-size: 0.85rem; opacity: 0.8; }
        .buy-banner-buttons { display: flex; gap: 12px; justify-content: center; }
        .buy-banner-btn { padding: 14px 28px; border: none; border-radius: 10px; font-family: inherit; font-weight: 700; font-size: 1rem; cursor: pointer; min-width: 100px; }
        .buy-btn-yes { background: var(--success); color: white; }
        .buy-btn-yes:hover { background: #059669; }
        .buy-btn-no { background: rgba(0,0,0,0.2); color: #000; }
        .buy-btn-no:hover { background: rgba(0,0,0,0.3); }
        
        /* Waiting for buyers indicator */
        .buy-waiting { display: none; position: fixed; top: 0; left: 0; right: 0; background: var(--card-bg); padding: 15px 20px; z-index: 500; border-bottom: 3px solid var(--warning); }
        .buy-waiting.active { display: block; animation: slideDown 0.3s ease; }
        .buy-waiting-content { max-width: 500px; margin: 0 auto; text-align: center; }
        .buy-waiting-title { font-weight: 700; color: var(--warning); margin-bottom: 5px; }
        .buy-waiting-detail { font-size: 0.9rem; color: var(--text-muted); }
        
        /* Next player notice */
        .next-player-notice { display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, var(--success), #059669); padding: 15px 20px; z-index: 500; }
        .next-player-notice.active { display: block; animation: slideDown 0.3s ease; }
        .next-player-notice-content { max-width: 500px; margin: 0 auto; text-align: center; color: white; }
        .next-player-notice-title { font-weight: 700; font-size: 1.1rem; }

        /* Toast */
        .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(100px); background: linear-gradient(135deg, var(--warning), #FF8F00); color: #000; padding: 18px 32px; border-radius: 50px; font-weight: 800; box-shadow: 0 10px 40px rgba(0,0,0,0.4); opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 2000; text-align: center; max-width: 90%; font-size: 1.05rem; text-transform: uppercase; letter-spacing: 1px; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Win Animation Overlay */
        .win-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .win-overlay.active { opacity: 1; pointer-events: auto; }
        .win-trophy { font-size: 8rem; animation: trophyBounce 1s ease infinite; }
        @keyframes trophyBounce { 0%, 100% { transform: scale(1) rotate(-5deg); } 50% { transform: scale(1.1) rotate(5deg); } }
        .win-title { font-size: 3rem; font-weight: 900; background: linear-gradient(135deg, #FFD700, #FFA500, #FF6347); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 20px 0; text-align: center; animation: winPulse 0.5s ease infinite alternate; }
        @keyframes winPulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        .win-subtitle { font-size: 1.3rem; color: var(--text-muted); margin-bottom: 30px; }
        .confetti { position: absolute; width: 10px; height: 10px; opacity: 0; }
        @keyframes confettiFall { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        
        /* Analytics Styles */
        .analytics-container { background: linear-gradient(135deg, var(--card-bg), #1a1a2e); border-radius: 16px; padding: 20px; margin: 15px 0; border: 2px solid rgba(255,255,255,0.1); }
        .analytics-title { font-size: 1.1rem; font-weight: 700; color: var(--warning); margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .analytics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .analytics-stat { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 12px; text-align: center; }
        .analytics-value { font-size: 1.5rem; font-weight: 800; color: var(--primary); }
        .analytics-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .analytics-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-top: 8px; }
        .analytics-bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
        
        /* Player row */
        .player-stats-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; background: rgba(0,0,0,0.2); border-radius: 12px; margin-bottom: 8px; }
        .player-stats-row.winner { background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,165,0,0.2)); border: 2px solid var(--warning); }
        .player-stats-name { font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .player-stats-score { font-weight: 800; }
        .player-stats-prob { font-size: 0.8rem; color: var(--text-muted); }
        .prob-high { color: var(--success); }
        .prob-med { color: var(--warning); }
        .prob-low { color: var(--danger); }

        /* responsive rules omitted for brevity - same as original */
    </style>
</head>
<body>
    <!-- WIN CELEBRATION OVERLAY -->
    <div class="win-overlay" id="win-overlay">
        <div class="win-trophy">üèÜ</div>
        <div class="win-title" id="win-title">YOU WIN!</div>
        <div class="win-subtitle" id="win-subtitle">Champion of Liverpool Rummy</div>
        <div id="win-confetti"></div>
    </div>

    <!-- BUY BANNER -->
    <div class="buy-banner" id="buy-banner">
        <div class="buy-banner-content">
            <div class="buy-banner-top">
                <div class="buy-banner-card" id="buy-banner-card"></div>
                <div class="buy-banner-text">
                    <div class="buy-banner-title">Buy this card?</div>
                    <div class="buy-banner-subtitle">You'll also draw 1 penalty card</div>
                </div>
            </div>
            <div class="buy-banner-buttons">
                <button class="buy-banner-btn buy-btn-yes" onclick="doBuy()">‚úì Buy It</button>
                <button class="buy-banner-btn buy-btn-no" onclick="doPass()">‚úó Pass</button>
            </div>
        </div>
    </div>

    <div class="buy-waiting" id="buy-waiting">
        <div class="buy-waiting-content">
            <div class="buy-waiting-title" id="buy-waiting-title">‚è≥ Waiting...</div>
            <div class="buy-waiting-detail" id="buy-waiting-detail"></div>
        </div>
    </div>

    <div class="next-player-notice" id="next-player-notice">
        <div class="next-player-notice-content">
            <div class="next-player-notice-title">üéØ You're next! You can take the discard on your turn</div>
        </div>
    </div>

    <!-- TITLE -->
    <div id="title-screen" class="screen active">
        <div class="logo">
            <h1>Liverpool Rummy</h1>
            <p>Contract Rummy Card Game</p>
        </div>
        <div class="menu-buttons">
            <button class="btn btn-primary" onclick="showScreen('mode-select')">üéÆ Play Game</button>
            <button class="btn btn-secondary" onclick="showRules()">üìñ How to Play</button>
            <button class="btn btn-secondary" onclick="showCustomizeCards()">üé® Custom Cards</button>
        </div>
    </div>

    <!-- MODE SELECT, PLAY TYPE, ONLINE/OFFLINE screens (same as original) -->
    <div id="mode-select" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('title-screen')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Select Game Mode</h2>
            <div class="mode-cards">
                <div class="mode-card" onclick="selectMode('classic')">
                    <div class="mode-icon">üÉè</div>
                    <div class="mode-title">Classic</div>
                    <div class="mode-desc">7 Contracts - Full Game</div>
                    <div class="mode-contracts">2 Sets ‚Üí 1+1 ‚Üí 2 Runs ‚Üí 3 Sets ‚Üí 2+1 ‚Üí 1+2 ‚Üí 3 Runs</div>
                </div>
                <div class="mode-card" onclick="selectMode('quick')">
                    <div class="mode-icon">‚ö°</div>
                    <div class="mode-title">Quick Rummy</div>
                    <div class="mode-desc">4 Contracts - Fast Game</div>
                    <div class="mode-contracts">2 Sets ‚Üí 2 Runs ‚Üí 3 Sets ‚Üí 3 Runs</div>
                </div>
            </div>
        </div>
    </div>

    <div id="play-type" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('mode-select')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title" id="play-type-title">Classic Mode</h2>
            <div class="menu-buttons">
                <button class="btn btn-primary" onclick="showScreen('online-menu')">üåê Play Online</button>
                <button class="btn btn-secondary" onclick="showScreen('solo-setup')">ü§ñ Play vs CPU</button>
            </div>
        </div>
    </div>

    <div id="online-menu" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('play-type')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Play Online</h2>
            <div class="menu-buttons">
                <button class="btn btn-primary" onclick="showScreen('create-room')">Create Game</button>
                <button class="btn btn-secondary" onclick="showScreen('join-room')">Join Game</button>
            </div>
        </div>
    </div>

    <div id="create-room" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('online-menu')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Create Game</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="host-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Number of Players</label>
                <div class="option-grid" id="player-count-grid">
                    <button class="option-btn" data-val="2">2</button>
                    <button class="option-btn selected" data-val="3">3</button>
                    <button class="option-btn" data-val="4">4</button>
                    <button class="option-btn" data-val="5">5</button>
                    <button class="option-btn" data-val="6">6</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">CPU Difficulty (if adding CPUs)</label>
                <div class="diff-grid" id="online-diff-grid">
                    <button class="diff-btn easy selected" data-val="easy">Easy</button>
                    <button class="diff-btn medium" data-val="medium">Medium</button>
                    <button class="diff-btn hard" data-val="hard">Hard</button>
                </div>
            </div>
            <button class="btn btn-success" onclick="createRoom()">Create Room</button>
        </div>
    </div>

    <div id="join-room" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('online-menu')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Join Game</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="join-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Room Code</label>
                <input type="text" id="room-code-input" class="form-input" placeholder="ABCD" maxlength="4" style="text-transform:uppercase;text-align:center;font-size:1.5rem;letter-spacing:0.3em;">
            </div>
            <button class="btn btn-success" onclick="joinRoom()">Join Room</button>
        </div>
    </div>

    <div id="lobby-host" class="screen setup-screen">
        <button class="back-btn" onclick="leaveRoom()">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Game Lobby</h2>
            <div class="room-code-box">
                <div class="room-code-label">Share this code with friends</div>
                <div class="room-code" id="display-code">----</div>
            </div>
            <div class="players-list">
                <div class="players-list-title">Players (<span id="p-count">0</span>/<span id="max-p">3</span>)</div>
                <div id="players-box"></div>
            </div>
            <button class="btn btn-secondary" id="add-cpu-btn" onclick="addCPU()" style="margin-bottom:15px;">ü§ñ Add CPU Player</button>
            <button class="btn btn-success" id="start-btn" onclick="startOnlineGame()" disabled>Waiting for players...</button>
        </div>
    </div>

    <div id="lobby-guest" class="screen setup-screen">
        <button class="back-btn" onclick="leaveRoom()">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Waiting for Host</h2>
            <div class="room-code-box">
                <div class="room-code-label">Room Code</div>
                <div class="room-code" id="display-code-guest">----</div>
            </div>
            <div class="players-list">
                <div class="players-list-title">Players</div>
                <div id="players-box-guest"></div>
            </div>
            <p style="text-align:center;color:var(--text-muted);">Waiting for host to start...</p>
        </div>
    </div>

    <div id="solo-setup" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('play-type')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Play vs CPU</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="solo-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Number of Players</label>
                <div class="option-grid" id="solo-player-grid">
                    <button class="option-btn" data-val="2">2</button>
                    <button class="option-btn selected" data-val="3">3</button>
                    <button class="option-btn" data-val="4">4</button>
                    <button class="option-btn" data-val="5">5</button>
                    <button class="option-btn" data-val="6">6</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">CPU Difficulty</label>
                <div class="diff-grid" id="diff-grid">
                    <button class="diff-btn easy selected" data-val="easy">Easy</button>
                    <button class="diff-btn medium" data-val="medium">Medium</button>
                    <button class="diff-btn hard" data-val="hard">Hard</button>
                </div>
            </div>
            <button class="btn btn-success" onclick="startSoloGame()">Start Game</button>
        </div>
    </div>

    <div id="game-screen" class="screen">
        <div class="game-header">
            <div class="contract-info">
                <div class="contract-num">Contract <span id="c-num">1</span> of <span id="c-total">7</span></div>
                <div class="contract-desc" id="c-desc">2 Sets</div>
            </div>
            <div class="game-stats">
                <div>Deck: <span id="deck-num">0</span></div>
                <div>Score: <span id="my-score">0</span></div>
            </div>
        </div>
        <div class="turn-indicator" id="turn-ind">Waiting...</div>
        <div class="opponents-row" id="opp-row"></div>
        <div class="table-area">
            <div class="pile deck-pile">
                <div class="pile-label">DRAW</div>
                <div class="pile-cards" onclick="drawDeck()">
                    <div class="card card-back"></div>
                    <span class="deck-count" id="deck-lbl">52</span>
                </div>
            </div>
            <div class="pile">
                <div class="pile-label">DISCARD</div>
                <div class="pile-cards" onclick="drawDiscard()">
                    <div class="card card-front" id="discard-top"></div>
                </div>
            </div>
        </div>
        <div class="melds-area">
            <div class="melds-title">Sets & Runs on Table</div>
            <div class="melds-container" id="melds-box"><span style="color:var(--text-muted);font-size:0.9rem;">None yet</span></div>
        </div>
        <div class="hand-area">
            <div class="hand-header">
                <span class="hand-title">Your Hand (<span id="hand-num">0</span>) <span id="my-prob" style="font-size:0.8rem;margin-left:8px;"></span></span>
                <div class="hand-controls">
                    <button class="sort-btn" id="btn-move-left" onclick="moveCardLeft()" title="Move Left">‚óÄ</button>
                    <button class="sort-btn" id="btn-move-right" onclick="moveCardRight()" title="Move Right">‚ñ∂</button>
                    <button class="sort-btn" onclick="sortHand()">Auto Sort</button>
                </div>
            </div>
            <div class="hand-cards" id="hand-box"></div>
            <div class="action-bar">
                <button class="action-btn btn-laydown" id="btn-lay" onclick="layDown()" disabled>Lay Down</button>
                <button class="action-btn btn-addto" id="btn-add" onclick="showAddModal()" disabled>Add To</button>
                <button class="action-btn btn-discard" id="btn-disc" onclick="doDiscard()" disabled>Discard</button>
            </div>
        </div>
    </div>

    <div class="modal-overlay" id="modal-overlay">
        <div class="modal">
            <h3 class="modal-title" id="modal-title">Modal</h3>
            <div class="modal-body" id="modal-body"></div>
            <div class="modal-buttons" id="modal-btns"></div>
        </div>
    </div>

    <div class="toast" id="toast"></div>

    <script>
        firebase.initializeApp({
            apiKey: "AIzaSyA_oxxemFHZUCkZ8rHZncw4ffILWNwKAw4",
            authDomain: "liverpool-9b034.firebaseapp.com",
            databaseURL: "https://liverpool-9b034-default-rtdb.firebaseio.com",
            projectId: "liverpool-9b034"
        });
        const db = firebase.database();

        const CUSTOM_CARDS = { joker: 'joker.jpeg', queen: 'queen.jpeg' };
        function loadCustomImages() {
            const joker = localStorage.getItem('customJoker');
            const queen = localStorage.getItem('customQueen');
            if (joker) CUSTOM_CARDS.jokerData = joker;
            if (queen) CUSTOM_CARDS.queenData = queen;
        }
        function setCustomImage(type, dataUrl) {
            if (type === 'joker') {
                CUSTOM_CARDS.jokerData = dataUrl;
                localStorage.setItem('customJoker', dataUrl);
            } else if (type === 'queen') {
                CUSTOM_CARDS.queenData = dataUrl;
                localStorage.setItem('customQueen', dataUrl);
            }
            if (G.started) render();
            toast('Custom ' + type + ' image set!');
        }
        function handleImageUpload(input, type) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => setCustomImage(type, e.target.result);
            reader.readAsDataURL(file);
        }
        function showCustomizeCards() {
            modal('Customize Cards', `
                <div style="text-align:center;">
                    <p style="margin-bottom:20px;color:var(--text-muted);">Upload photos to use as card faces!</p>
                    <div style="margin-bottom:25px;">
                        <div style="font-weight:700;margin-bottom:10px;">üÉè Joker Card</div>
                        <label class="btn btn-secondary btn-sm" style="cursor:pointer;">
                            Choose Photo
                            <input type="file" accept="image/*" style="display:none;" onchange="handleImageUpload(this, 'joker')">
                        </label>
                        ${CUSTOM_CARDS.jokerData ? '<div style="color:var(--success);margin-top:8px;">‚úì Custom image set</div>' : ''}
                    </div>
                    <div style="margin-bottom:25px;">
                        <div style="font-weight:700;margin-bottom:10px;">üëë Queen Cards</div>
                        <label class="btn btn-secondary btn-sm" style="cursor:pointer;">
                            Choose Photo
                            <input type="file" accept="image/*" style="display:none;" onchange="handleImageUpload(this, 'queen')">
                        </label>
                        ${CUSTOM_CARDS.queenData ? '<div style="color:var(--success);margin-top:8px;">‚úì Custom image set</div>' : ''}
                    </div>
                    <div style="margin-top:20px;padding-top:15px;border-top:1px solid var(--card-hover);">
                        <button class="btn btn-danger btn-sm" onclick="clearCustomImages()" style="width:auto;padding:10px 20px;">
                            Clear All Custom Images
                        </button>
                    </div>
                </div>
            `, [{text:'Done', cls:'btn-primary'}]);
        }
        function clearCustomImages() {
            localStorage.removeItem('customJoker');
            localStorage.removeItem('customQueen');
            delete CUSTOM_CARDS.jokerData;
            delete CUSTOM_CARDS.queenData;
            toast('Custom images cleared');
            closeModal();
        }
        loadCustomImages();

        const SUITS = ['hearts','diamonds','clubs','spades'];
        const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const RANK_VAL = {A:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:10,J:11,Q:12,K:13};
        const POINTS = {A:15,2:20,3:5,4:5,5:5,6:5,7:5,8:5,9:5,10:10,J:10,Q:10,K:10,JOKER:20};
        const SUIT_SYM = {hearts:'‚ô•',diamonds:'‚ô¶',clubs:'‚ô£',spades:'‚ô†'};

        const CLASSIC_CONTRACTS = [
            {id:1,sets:2,runs:0,cards:7,desc:'2 Sets'},
            {id:2,sets:1,runs:1,cards:8,desc:'1 Set + 1 Run'},
            {id:3,sets:0,runs:2,cards:9,desc:'2 Runs'},
            {id:4,sets:3,runs:0,cards:10,desc:'3 Sets'},
            {id:5,sets:2,runs:1,cards:11,desc:'2 Sets + 1 Run'},
            {id:6,sets:1,runs:2,cards:12,desc:'1 Set + 2 Runs'},
            {id:7,sets:0,runs:3,cards:13,desc:'3 Runs (all cards)'}
        ];
        const QUICK_CONTRACTS = [
            {id:1,sets:2,runs:0,cards:7,desc:'2 Sets'},
            {id:2,sets:0,runs:2,cards:9,desc:'2 Runs'},
            {id:3,sets:3,runs:0,cards:10,desc:'3 Sets'},
            {id:4,sets:0,runs:3,cards:13,desc:'3 Runs (all cards)'}
        ];
        let CONTRACTS = CLASSIC_CONTRACTS;
        let gameMode = 'classic';
        const CPU_NAMES = ['Ruby','Emerald','Sapphire','Topaz','Amethyst','Opal'];

        let G = {players:[],deck:[],discard:[],melds:[],cur:0,contract:0,phase:'draw',drawn:false,buyQ:[],buyer:-1,started:false,hostId:null,deadCards:[]};
        let L = {myId:null,myName:'Player',isHost:false,isOnline:false,code:null,roomRef:null,gameRef:null,sel:[],maxP:3,diff:'easy'};

        let analytics = {
            roundsPlayed: 0,
            roundWins: {},
            cardsBought: {},
            cardsPlayed: {},
            wildsUsed: {},
            turnsPlayed: {}
        };
        function resetAnalytics() {
            analytics = {roundsPlayed:0,roundWins:{},cardsBought:{},cardsPlayed:{},wildsUsed:{},turnsPlayed:{}};
        }
        function trackStat(stat, playerName, amount = 1) {
            if (!analytics[stat][playerName]) analytics[stat][playerName] = 0;
            analytics[stat][playerName] += amount;
        }
        function calculateWinProbability(player, allPlayers) {
            const scores = allPlayers.map(p => p.score);
            const minScore = Math.min(...scores);
            const maxScore = Math.max(...scores);
            const scoreRange = maxScore - minScore || 1;
            const scoreFactor = 1 - ((player.score - minScore) / scoreRange);
            const handSizes = allPlayers.map(p => p.hand?.length || 0);
            const maxHand = Math.max(...handSizes) || 1;
            const handFactor = 1 - ((player.hand?.length || 0) / maxHand);
            const roundWins = analytics.roundWins[player.name] || 0;
            const maxRoundWins = Math.max(...Object.values(analytics.roundWins), 1);
            const roundWinFactor = roundWins / maxRoundWins;
            const laidFactor = player.laid ? 1 : 0;
            let prob = (
                scoreFactor * 0.4 +
                handFactor * 0.25 +
                roundWinFactor * 0.2 +
                laidFactor * 0.15
            );
            prob = Math.round(prob * 100);
            return Math.max(5, Math.min(95, prob));
        }

        function selectMode(mode) {
            gameMode = mode;
            if (mode === 'quick') {
                CONTRACTS = QUICK_CONTRACTS;
                document.getElementById('play-type-title').textContent = '‚ö° Quick Rummy';
            } else {
                CONTRACTS = CLASSIC_CONTRACTS;
                document.getElementById('play-type-title').textContent = 'üÉè Classic Mode';
            }
            showScreen('play-type');
        }

        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
        }

        document.querySelectorAll('.option-grid, .diff-grid').forEach(grid => {
            grid.onclick = e => {
                const btn = e.target.closest('.option-btn, .diff-btn');
                if (!btn) return;
                grid.querySelectorAll('.option-btn, .diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            };
        });

        function toast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2500);
        }

        function modal(title, body, btns) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').innerHTML = body;
            const bc = document.getElementById('modal-btns');
            bc.innerHTML = '';
            btns.forEach(b => {
                const btn = document.createElement('button');
                btn.className = 'btn ' + (b.cls || 'btn-secondary');
                btn.textContent = b.text;
                btn.onclick = () => { closeModal(); if (b.fn) b.fn(); };
                bc.appendChild(btn);
            });
            document.getElementById('modal-overlay').classList.add('active');
        }
        function closeModal() { document.getElementById('modal-overlay').classList.remove('active'); }

        let cardIdCounter = 0;
        function makeDeck(n) {
            const d = [];
            for (let i = 0; i < n; i++) {
                for (const s of SUITS) {
                    for (const r of RANKS) {
                        d.push({id: cardIdCounter++, suit:s, rank:r, wild: r==='2'});
                    }
                }
            }
            d.push({id: cardIdCounter++, suit:null,rank:'JOKER',wild:true});
            d.push({id: cardIdCounter++, suit:null,rank:'JOKER',wild:true});
            return shuffle(d);
        }
        function shuffle(a) {
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }
        function numDecks(p) { return p <= 4 ? 2 : 2 + Math.floor((p - 4) / 2); }

        function genCode() {
            const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let r = '';
            for (let i = 0; i < 4; i++) r += c[Math.floor(Math.random() * c.length)];
            return r;
        }

        async function createRoom() {
            const name = document.getElementById('host-name').value.trim() || 'Host';
            const max = parseInt(document.querySelector('#player-count-grid .selected').dataset.val);
            const diffBtn = document.querySelector('#online-diff-grid .selected');
            L.diff = diffBtn ? diffBtn.dataset.val : 'easy';
            L.myName = name; L.myId = 'p_' + Date.now(); L.isHost = true; L.isOnline = true; L.maxP = max; L.code = genCode();
            const data = {code: L.code, hostId: L.myId, maxP: max, difficulty: L.diff, players: {[L.myId]: {name, isHost:true, isCPU:false, conn:true}}, started:false};
            try {
                L.roomRef = db.ref('rooms/' + L.code);
                await L.roomRef.set(data);
                L.roomRef.child('players/' + L.myId + '/conn').onDisconnect().set(false);
                L.roomRef.on('value', onRoom);
                document.getElementById('display-code').textContent = L.code;
                document.getElementById('max-p').textContent = max;
                showScreen('lobby-host');
                toast('Room created!');
            } catch (e) { toast('Error: ' + e.message); }
        }

        async function joinRoom() {
            const name = document.getElementById('join-name').value.trim() || 'Player';
            const code = document.getElementById('room-code-input').value.toUpperCase().trim();
            if (code.length !== 4) return toast('Enter 4-letter code');
            L.myName = name; L.myId = 'p_' + Date.now(); L.isHost = false; L.isOnline = true; L.code = code;
            try {
                L.roomRef = db.ref('rooms/' + code);
                const snap = await L.roomRef.once('value');
                const d = snap.val();
                if (!d) return toast('Room not found');
                if (d.started) return toast('Game already started');
                const cnt = Object.values(d.players || {}).filter(p => p.conn).length;
                if (cnt >= d.maxP) return toast('Room is full');
                await L.roomRef.child('players/' + L.myId).set({name, isHost:false, isCPU:false, conn:true});
                L.roomRef.child('players/' + L.myId + '/conn').onDisconnect().set(false);
                L.roomRef.on('value', onRoom);
                document.getElementById('display-code-guest').textContent = code;
                showScreen('lobby-guest');
                toast('Joined!');
            } catch (e) { toast('Error: ' + e.message); }
        }

        function onRoom(snap) {
            const d = snap.val();
            if (!d) { toast('Room closed'); showScreen('title-screen'); return; }
            const ps = Object.entries(d.players || {}).filter(([,p]) => p.conn !== false);
            if (L.isHost) updateHostLobby(ps, d.maxP);
            else updateGuestLobby(ps);
            if (d.started && d.game) {
                G = fixGameState(d.game);
                L.gameRef = L.roomRef.child('game');
                L.gameRef.on('value', onGame);
                showScreen('game-screen');
                render();
            }
        }

        function updateHostLobby(ps, max) {
            document.getElementById('p-count').textContent = ps.length;
            document.getElementById('max-p').textContent = max;
            document.getElementById('players-box').innerHTML = ps.map(([id, p]) => `
                <div class="player-row">
                    <span class="player-name">${p.isCPU ? 'ü§ñ ' : ''}${p.name}
                        ${id === L.myId ? '<span class="badge badge-you">You</span>' : ''}
                        ${p.isHost ? '<span class="badge badge-host">Host</span>' : ''}
                    </span>
                    ${p.isCPU ? `<button class="remove-btn" onclick="removeCPU('${id}')">√ó</button>` : ''}
                </div>
            `).join('');
            document.getElementById('add-cpu-btn').style.display = ps.length >= max ? 'none' : 'flex';
            const btn = document.getElementById('start-btn');
            btn.disabled = ps.length < 2;
            btn.textContent = ps.length < 2 ? 'Need 2+ players' : 'Start Game';
        }

        function updateGuestLobby(ps) {
            document.getElementById('players-box-guest').innerHTML = ps.map(([id, p]) => `
                <div class="player-row">
                    <span class="player-name">${p.isCPU ? 'ü§ñ ' : ''}${p.name}
                        ${id === L.myId ? '<span class="badge badge-you">You</span>' : ''}
                        ${p.isHost ? '<span class="badge badge-host">Host</span>' : ''}
                    </span>
                </div>
            `).join('');
        }

        async function addCPU() {
            const snap = await L.roomRef.once('value');
            const d = snap.val();
            const ps = Object.values(d.players || {}).filter(p => p.conn !== false);
            if (ps.length >= d.maxP) return toast('Room full');
            const used = ps.map(p => p.name);
            const name = CPU_NAMES.find(n => !used.includes(n)) || 'CPU';
            await L.roomRef.child('players/cpu_' + Date.now()).set({name, isHost:false, isCPU:true, conn:true});
            toast('Added ' + name);
        }

        async function removeCPU(id) { await L.roomRef.child('players/' + id).remove(); }

        async function leaveRoom() {
            if (L.roomRef) {
                if (L.isHost) await L.roomRef.remove();
                else await L.roomRef.child('players/' + L.myId).remove();
                L.roomRef.off();
                if (L.gameRef) L.gameRef.off();
            }
            L.isOnline = false;
            showScreen('title-screen');
        }

        async function startOnlineGame() {
            const snap = await L.roomRef.once('value');
            const d = snap.val();
            const ps = Object.entries(d.players || {}).filter(([,p]) => p.conn !== false);
            L.diff = d.difficulty || 'easy';
            initGame(ps.map(([id, p]) => ({id, name: p.name, human: !p.isCPU, cpu: p.isCPU})));
            G.hostId = L.myId;
            await L.roomRef.update({started: true, game: G});
            setTimeout(() => { if (G.players[0]?.cpu) checkCPU(); }, 500);
        }

        function fixGameState(g) {
            if (!g) return g;
            const fixCardWild = (card) => {
                if (card && (card.rank === '2' || card.rank === 'JOKER')) card.wild = true;
                return card;
            };
            const fixCardsArray = (cards) => {
                if (!cards) return [];
                if (!Array.isArray(cards)) cards = Object.values(cards);
                return cards.map(fixCardWild);
            };
            if (g.deck && !Array.isArray(g.deck)) g.deck = Object.values(g.deck);
            g.deck = fixCardsArray(g.deck);
            if (g.discard && !Array.isArray(g.discard)) g.discard = Object.values(g.discard);
            g.discard = fixCardsArray(g.discard);
            if (g.melds && !Array.isArray(g.melds)) g.melds = Object.values(g.melds);
            g.melds = g.melds || [];
            g.melds.forEach(m => { if (m.cards && !Array.isArray(m.cards)) m.cards = Object.values(m.cards); m.cards = fixCardsArray(m.cards); });
            if (g.players && !Array.isArray(g.players)) g.players = Object.values(g.players);
            g.players = g.players || [];
            g.players.forEach(p => { if (p.hand && !Array.isArray(p.hand)) p.hand = Object.values(p.hand); p.hand = fixCardsArray(p.hand); });
            if (g.buyQ && !Array.isArray(g.buyQ)) g.buyQ = Object.values(g.buyQ);
            g.buyQ = g.buyQ || [];
            if (g.deadCards && !Array.isArray(g.deadCards)) g.deadCards = Object.values(g.deadCards);
            g.deadCards = g.deadCards || [];
            return g;
        }

        function onGame(snap) {
            const d = snap.val();
            if (!d) return;
            G = fixGameState(d);
            L.sel = [];
            render();
            if (L.isHost && !cpuRunning && !cpuBuyingRunning) {
                setTimeout(() => { checkCPU(); checkCPUBuying(); }, 100);
            }
        }

        function sync() {
            if (L.isOnline && L.roomRef) {
                L.roomRef.child('game').set(G);
            } else {
                render();
                setTimeout(() => { checkCPU(); checkCPUBuying(); }, 100);
            }
        }

        function startSoloGame() {
            const name = document.getElementById('solo-name').value.trim() || 'You';
            const num = parseInt(document.querySelector('#solo-player-grid .selected').dataset.val);
            L.diff = document.querySelector('#diff-grid .selected').dataset.val;
            L.myName = name; L.myId = 'human'; L.isHost = true; L.isOnline = false;
            const ps = [{id:'human', name, human:true, cpu:false}];
            const used = [name];
            for (let i = 1; i < num; i++) {
                const n = CPU_NAMES.find(x => !used.includes(x)) || 'CPU' + i;
                used.push(n);
                ps.push({id:'cpu_'+i, name:n, human:false, cpu:true});
            }
            resetAnalytics();
            initGame(ps);
            showScreen('game-screen');
            render();
            if (G.players[0].cpu) setTimeout(cpuTurn, 1000);
        }

        function initGame(ps) {
            const c = CONTRACTS[0];
            G = {
                players: ps.map(p => ({...p, hand:[], score:0, laid:false})),
                deck: makeDeck(numDecks(ps.length)),
                discard: [],
                melds: [],
                cur: 0,
                contract: 0,
                phase: 'draw',
                drawn: false,
                buyQ: [],
                buyer: -1,
                started: true,
                hostId: L.myId,
                difficulty: L.diff || 'easy',
                deadCards: []
            };
            for (let i = 0; i < c.cards; i++) G.players.forEach(p => G.deck.length && p.hand.push(G.deck.pop()));
            G.discard.push(G.deck.pop());
        }

        function render() {
            const me = getMe();
            const c = CONTRACTS[G.contract];
            document.getElementById('c-num').textContent = c.id;
            document.getElementById('c-total').textContent = CONTRACTS.length;
            document.getElementById('c-desc').textContent = c.desc;
            document.getElementById('deck-num').textContent = G.deck.length;
            document.getElementById('deck-lbl').textContent = G.deck.length;
            document.getElementById('my-score').textContent = me.score;
            const myProb = calculateWinProbability(me, G.players);
            const probEl = document.getElementById('my-prob');
            const probClass = myProb >= 50 ? 'prob-high' : myProb >= 25 ? 'prob-med' : 'prob-low';
            probEl.className = probClass;
            probEl.textContent = myProb + '% win';

            const ti = document.getElementById('turn-ind');
            const buyBanner = document.getElementById('buy-banner');
            const buyWaiting = document.getElementById('buy-waiting');
            const nextNotice = document.getElementById('next-player-notice');
            buyBanner.classList.remove('active');
            buyWaiting.classList.remove('active');
            nextNotice.classList.remove('active');
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const imNextPlayer = G.players[nextPlayerIdx]?.id === L.myId;
            if (G.phase === 'buying' && amBuying()) {
                const position = G.players.findIndex(p => p.id === L.myId);
                const isFirst = position === nextPlayerIdx;
                ti.textContent = isFirst ? 'üõí First dibs! Buy this card?' : 'üõí Your turn to buy!';
                ti.className = 'turn-indicator your-turn';
                showBuyBanner();
            } else if (G.phase === 'buying') {
                ti.textContent = '‚è≥ ' + (G.players[G.buyer]?.name || '') + ' deciding...';
                ti.className = 'turn-indicator waiting';
                const buyer = G.players[G.buyer];
                const buyerIsNext = G.buyer === nextPlayerIdx;
                document.getElementById('buy-waiting-title').textContent = `‚è≥ ${buyer?.name || 'Someone'} is deciding...`;
                document.getElementById('buy-waiting-detail').textContent = buyerIsNext ? `They have first dibs on the discarded card` : `Waiting for buy decision (+1 penalty card to buy)`;
                buyWaiting.classList.add('active');
            } else if (myTurn()) {
                ti.textContent = G.drawn ? 'üé¥ Play cards or select 1 to discard' : 'üëÜ Tap DRAW or DISCARD pile to draw';
                ti.className = 'turn-indicator your-turn';
            } else {
                ti.textContent = '‚è≥ ' + (G.players[G.cur]?.name || '') + "'s turn";
                ti.className = 'turn-indicator waiting';
            }

            document.getElementById('opp-row').innerHTML = G.players.map((p, i) => {
                if (p.id === L.myId) return '';
                const act = i === G.cur && G.phase !== 'buying';
                const buying = G.phase === 'buying' && i === G.buyer;
                const prob = calculateWinProbability(p, G.players);
                const probClass = prob >= 50 ? 'prob-high' : prob >= 25 ? 'prob-med' : 'prob-low';
                return `<div class="opponent-card ${act ? 'active' : ''} ${buying ? 'buying' : ''}">
                    <div class="opponent-name">${p.cpu ? 'ü§ñ ' : ''}${p.name}</div>
                    <div class="opponent-cards">${p.hand.length} cards</div>
                    <div class="opponent-status">Score: ${p.score} ‚Ä¢ <span class="${probClass}">${prob}%</span></div>
                    ${p.laid ? '<div class="laid-badge">‚úì Laid</div>' : ''}
                    ${buying ? '<div class="laid-badge" style="background:var(--warning);color:#000;">Buying...</div>' : ''}
                </div>`;
            }).join('');

            const dt = document.getElementById('discard-top');
            if (G.discard.length) {
                const top = G.discard[G.discard.length - 1];
                const topIsDead = isDeadCard(top);
                const deadOverlay = topIsDead ? '<div class="card-dead-overlay">üíÄ</div>' : '';
                const deadClass = topIsDead ? ' dead-card' : '';
                if (top.rank === 'JOKER') {
                    dt.className = 'card card-front card-appear wild' + (CUSTOM_CARDS.jokerData ? ' joker-custom' : '') + deadClass;
                    dt.style.backgroundImage = CUSTOM_CARDS.jokerData ? `url('${CUSTOM_CARDS.jokerData}')` : '';
                    dt.innerHTML = deadOverlay + '<span class="card-rank">J</span><span class="card-suit">üÉè</span>';
                } else if (top.rank === 'Q') {
                    dt.className = 'card card-front card-appear ' + top.suit + (CUSTOM_CARDS.queenData ? ' queen-custom' : '') + deadClass;
                    dt.style.backgroundImage = CUSTOM_CARDS.queenData ? `url('${CUSTOM_CARDS.queenData}')` : '';
                    dt.innerHTML = deadOverlay + `<span class="card-rank">Q</span><span class="card-suit">${SUIT_SYM[top.suit]}</span>`;
                } else {
                    dt.className = 'card card-front card-appear ' + (top.wild ? 'wild' : top.suit) + deadClass;
                    dt.style.backgroundImage = '';
                    dt.innerHTML = deadOverlay + `<span class="card-rank">${top.rank}</span><span class="card-suit">${SUIT_SYM[top.suit]}</span>`;
                }
            } else {
                dt.className = 'card card-front';
                dt.style.backgroundImage = '';
                dt.innerHTML = '';
            }

            const mb = document.getElementById('melds-box');
            if (!G.melds.length) {
                mb.innerHTML = '<span style="color:var(--text-muted);font-size:0.9rem;">None yet</span>';
            } else {
                mb.innerHTML = G.melds.map(m => `
                    <div class="meld-group">
                        <div class="meld-label">${m.owner}'s ${m.type}</div>
                        <div class="meld-cards">${m.cards.map(cardHtml).join('')}</div>
                    </div>
                `).join('');
            }

            document.getElementById('hand-box').innerHTML = me.hand.map((c, i) => cardHtml(c, i, true)).join('');
            document.getElementById('hand-num').textContent = me.hand.length;
            updateBtns();
        }

        function isDeadCard(c) {
            if (!G.deadCards || !G.deadCards.length) return false;
            if (c.id !== undefined) return G.deadCards.some(d => d.id === c.id);
            return G.deadCards.some(d => d.rank === c.rank && d.suit === c.suit && d.wild === c.wild);
        }

        function cardHtml(c, idx = null, hand = false) {
            const sel = idx !== null && L.sel.includes(idx) ? 'selected' : '';
            const isDead = isDeadCard(c);
            const deadClass = isDead ? 'dead-card' : '';
            const click = hand && idx !== null ? `onclick="toggleCard(${idx})"` : '';
            const drag = hand && idx !== null ? `draggable="true" data-idx="${idx}"` : '';
            const deadOverlay = isDead ? '<div class="card-dead-overlay">üíÄ</div>' : '';
            if (c.rank === 'JOKER') {
                const style = CUSTOM_CARDS.jokerData ? `style="background-image: url('${CUSTOM_CARDS.jokerData}')"` : '';
                const cls = CUSTOM_CARDS.jokerData ? 'wild joker-custom' : 'wild';
                return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${style} ${click} ${drag}>
                    ${deadOverlay}
                    <span class="card-rank">J</span>
                    <span class="card-suit">üÉè</span>
                </div>`;
            }
            if (c.rank === 'Q') {
                const style = CUSTOM_CARDS.queenData ? `style="background-image: url('${CUSTOM_CARDS.queenData}')"` : '';
                const cls = CUSTOM_CARDS.queenData ? `${c.suit} queen-custom` : c.suit;
                return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${style} ${click} ${drag}>
                    ${deadOverlay}
                    <span class="card-rank">Q</span>
                    <span class="card-suit">${SUIT_SYM[c.suit]}</span>
                </div>`;
            }
            const cls = c.wild ? 'wild' : c.suit;
            const cnt = `${deadOverlay}<span class="card-rank">${c.rank}</span><span class="card-suit">${SUIT_SYM[c.suit]}</span>`;
            return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${click} ${drag}>${cnt}</div>`;
        }

        function updateBtns() {
            const me = getMe();
            const turn = myTurn();
            const drawn = G.drawn;
            const buying = G.phase === 'buying';
            document.getElementById('btn-lay').disabled = !(turn && drawn && !me.laid && L.sel.length > 0 && !buying);
            document.getElementById('btn-add').disabled = !(turn && drawn && me.laid && G.melds.length && L.sel.length && !buying);
            document.getElementById('btn-disc').disabled = !(turn && drawn && L.sel.length === 1 && !buying);
            const moveLeft = document.getElementById('btn-move-left');
            const moveRight = document.getElementById('btn-move-right');
            if (moveLeft && moveRight) {
                moveLeft.disabled = L.sel.length !== 1 || L.sel[0] === 0;
                moveRight.disabled = L.sel.length !== 1 || L.sel[0] >= me.hand.length - 1;
            }
        }

        function getMe() { return G.players.find(p => p.id === L.myId) || G.players[0]; }
        function myIdx() { return G.players.findIndex(p => p.id === L.myId); }
        function myTurn() { return G.players[G.cur]?.id === L.myId; }
        function amBuying() { return G.buyer >= 0 && G.players[G.buyer]?.id === L.myId; }
        function isFinalContract() { return G.contract === CONTRACTS.length - 1; }
        function isLastContract() { return G.contract >= CONTRACTS.length - 1; }

        function toggleCard(i) {
            if (G.phase === 'buying') return toast('Wait for buying');
            if (!myTurn()) return toast('Not your turn');
            if (!G.drawn) return toast('Draw first');
            const x = L.sel.indexOf(i);
            if (x > -1) L.sel.splice(x, 1);
            else L.sel.push(i);
            render();
        }

        function sortHand() {
            const me = getMe();
            me.hand.sort((a, b) => {
                if (a.wild && !b.wild) return 1;
                if (!a.wild && b.wild) return -1;
                if (a.suit !== b.suit) return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
                return RANK_VAL[a.rank] - RANK_VAL[b.rank];
            });
            L.sel = [];
            sync();
        }
        
        function moveCardLeft() {
            if (L.sel.length !== 1) return toast('Select 1 card to move');
            const me = getMe();
            const idx = L.sel[0];
            if (idx <= 0) return;
            [me.hand[idx], me.hand[idx - 1]] = [me.hand[idx - 1], me.hand[idx]];
            L.sel = [idx - 1];
            render();
        }
        
        function moveCardRight() {
            if (L.sel.length !== 1) return toast('Select 1 card to move');
            const me = getMe();
            const idx = L.sel[0];
            if (idx >= me.hand.length - 1) return;
            [me.hand[idx], me.hand[idx + 1]] = [me.hand[idx + 1], me.hand[idx]];
            L.sel = [idx + 1];
            render();
        }

        // Drag drop same as original
        let draggedIdx = null;
        function setupDragDrop() {
            const handBox = document.getElementById('hand-box');
            handBox.addEventListener('dragstart', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (!card) return;
                draggedIdx = parseInt(card.dataset.idx);
                card.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            handBox.addEventListener('dragend', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (card) card.classList.remove('dragging');
                document.querySelectorAll('.card.drag-over').forEach(c => c.classList.remove('drag-over'));
                draggedIdx = null;
            });
            handBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                const card = e.target.closest('.card[data-idx]');
                if (card && parseInt(card.dataset.idx) !== draggedIdx) {
                    document.querySelectorAll('.card.drag-over').forEach(c => c.classList.remove('drag-over'));
                    card.classList.add('drag-over');
                }
            });
            handBox.addEventListener('dragleave', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (card) card.classList.remove('drag-over');
            });
            handBox.addEventListener('drop', (e) => {
                e.preventDefault();
                const card = e.target.closest('.card[data-idx]');
                if (!card || draggedIdx === null) return;
                const dropIdx = parseInt(card.dataset.idx);
                if (dropIdx === draggedIdx) return;
                const me = getMe();
                const [draggedCard] = me.hand.splice(draggedIdx, 1);
                me.hand.splice(dropIdx, 0, draggedCard);
                L.sel = [];
                render();
            });
        }
        document.addEventListener('DOMContentLoaded', setupDragDrop);

        function drawDeck() {
            if (!myTurn()) return toast('Not your turn');
            if (G.drawn) return toast('Already drew');
            if (G.phase === 'buying') return;
            reshuffle();
            getMe().hand.push(G.deck.pop());
            G.drawn = true;
            G.phase = 'play';
            sync();
        }

        function drawDiscard() {
            if (!myTurn()) return toast('Not your turn');
            if (G.drawn) return toast('Already drew');
            if (G.phase === 'buying') return;
            if (!G.discard.length) return toast('Empty');
            const topCard = G.discard[G.discard.length - 1];
            if (isDeadCard(topCard)) return toast('üíÄ Dead card! Draw from deck instead');
            if (G.discard.length > 1) {
                const buried = G.discard.slice(0, -1);
                G.deadCards = G.deadCards || [];
                buried.forEach(c => { if (!G.deadCards.some(d => d.id === c.id)) G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild}); });
            }
            getMe().hand.push(G.discard.pop());
            G.drawn = true;
            G.phase = 'play';
            sync();
        }

        function reshuffle() {
            if (!G.deck.length && G.discard.length > 1) {
                const top = G.discard.pop();
                G.deck = shuffle(G.discard);
                G.discard = [top];
                toast('Reshuffled');
            }
        }

        function doDiscard() {
            if (!myTurn()) return toast('Not your turn');
            if (!G.drawn) return toast('Draw first');
            if (L.sel.length !== 1) return toast('Select 1 card');
            const me = getMe();
            const card = me.hand[L.sel[0]];
            if (isFinalContract() && me.laid && me.hand.length === 1 && card.wild) return toast('Final contract: Cannot discard a wild!');
            G.discard.push(card);
            me.hand.splice(L.sel[0], 1);
            L.sel = [];
            if (!me.hand.length && me.laid) { sync(); endRound(myIdx()); return; }
            render();
            setTimeout(startBuying, 300);
        }

        function startBuying() {
            if (G.discard.length > 0) {
                const topCard = G.discard[G.discard.length - 1];
                if (isDeadCard(topCard)) { nextTurn(); return; }
            }
            G.buyQ = [];
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            G.buyQ.push(nextPlayerIdx);
            for (let i = 2; i < G.players.length; i++) G.buyQ.push((G.cur + i) % G.players.length);
            G.phase = 'buying';
            G.buyer = G.buyQ.shift();
            sync();
        }

        function nextBuyer() {
            if (G.buyQ.length) {
                G.buyer = G.buyQ.shift();
                cpuBuyingRunning = false;
                sync();
            } else {
                G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                nextTurn();
            }
        }

        function showBuyBanner() {
            if (!G.discard.length) return;
            const top = G.discard[G.discard.length - 1];
            const banner = document.getElementById('buy-banner');
            const cardEl = document.getElementById('buy-banner-card');
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const buyerIsNextPlayer = G.buyer === nextPlayerIdx;
            const titleEl = banner.querySelector('.buy-banner-title');
            const subtitleEl = banner.querySelector('.buy-banner-subtitle');
            const buyBtnEl = banner.querySelector('.buy-btn-yes');
            if (buyerIsNextPlayer) {
                titleEl.textContent = 'Take this card?';
                subtitleEl.textContent = "It's your turn - take it FREE!";
                buyBtnEl.textContent = '‚úì Take It';
            } else {
                titleEl.textContent = 'Buy this card?';
                subtitleEl.textContent = "You'll also draw 1 penalty card";
                buyBtnEl.textContent = '‚úì Buy It';
            }
            if (top.rank === 'JOKER' && CUSTOM_CARDS.jokerData) {
                cardEl.className = 'buy-banner-card joker-custom';
                cardEl.style.backgroundImage = `url('${CUSTOM_CARDS.jokerData}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center top';
                cardEl.innerHTML = '<span style="font-size:1.5rem;text-shadow:2px 2px 4px rgba(0,0,0,0.8);">J</span>';
            } else if (top.rank === 'Q' && CUSTOM_CARDS.queenData) {
                cardEl.className = 'buy-banner-card queen-custom ' + top.suit;
                cardEl.style.backgroundImage = `url('${CUSTOM_CARDS.queenData}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center top';
                cardEl.innerHTML = `<span style="font-size:1.5rem;text-shadow:2px 2px 4px rgba(0,0,0,0.8);">Q</span>`;
            } else {
                cardEl.className = 'buy-banner-card ' + (top.wild ? 'wild' : top.suit);
                cardEl.style.backgroundImage = '';
                cardEl.innerHTML = top.rank === 'JOKER' ? 'J<br>üÉè' : `${top.rank}<br>${SUIT_SYM[top.suit]}`;
            }
            banner.classList.add('active');
        }

        function hideBuyBanner() {
            document.getElementById('buy-banner').classList.remove('active');
            document.getElementById('buy-waiting').classList.remove('active');
            document.getElementById('next-player-notice').classList.remove('active');
        }

        function doBuy() {
            if (!amBuying()) return;
            hideBuyBanner();
            const me = getMe();
            const myIdx = G.players.findIndex(p => p.id === L.myId);
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const iAmNextPlayer = myIdx === nextPlayerIdx;
            trackStat('cardsBought', me.name);
            if (G.discard.length > 1) {
                const buried = G.discard.slice(0, -1);
                G.deadCards = G.deadCards || [];
                buried.forEach(c => { if (!G.deadCards.some(d => d.id === c.id)) G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild}); });
            }
            me.hand.push(G.discard.pop());
            if (iAmNextPlayer) {
                toast('Took the discard!');
                G.cur = myIdx;
                G.drawn = true;
                G.phase = 'play';
                G.buyer = -1;
                G.buyQ = [];
                L.sel = [];
                sync();
            } else {
                reshuffle();
                if (G.deck.length) me.hand.push(G.deck.pop());
                toast('Bought! +1 penalty card');
                G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                nextTurn();
            }
        }

        function doPass() {
            if (!amBuying()) return;
            hideBuyBanner();
            nextBuyer();
        }

        function nextTurn() {
            cpuRunning = false;
            cpuBuyingRunning = false;
            G.cur = (G.cur + 1) % G.players.length;
            G.drawn = false;
            G.phase = 'draw';
            G.buyer = -1;
            G.buyQ = [];
            L.sel = [];
            sync();
        }

        let cpuRunning = false;
        function checkCPU() {
            if (cpuRunning) return;
            const p = G.players[G.cur];
            if (p?.cpu && G.phase === 'draw' && !G.drawn) {
                cpuRunning = true;
                setTimeout(() => { cpuTurn(); }, 1000);
            }
        }
        let cpuBuyingRunning = false;
        function checkCPUBuying() {
            if (G.phase !== 'buying') return;
            if (cpuBuyingRunning) return;
            const p = G.players[G.buyer];
            if (p?.cpu) {
                cpuBuyingRunning = true;
                setTimeout(() => {
                    const top = G.discard[G.discard.length - 1];
                    const diff = G.difficulty || 'easy';
                    const nextPlayerIdx = (G.cur + 1) % G.players.length;
                    const isNextPlayer = G.buyer === nextPlayerIdx;
                    let shouldTake = false;
                    if (isNextPlayer) {
                        const takeChance = diff === 'hard' ? 0.7 : diff === 'medium' ? 0.5 : 0.3;
                        shouldTake = top?.wild || Math.random() < takeChance;
                    } else {
                        const buyChance = diff === 'hard' ? 0.4 : diff === 'medium' ? 0.3 : 0.15;
                        shouldTake = top?.wild || Math.random() < buyChance;
                    }
                    if (shouldTake) {
                        if (G.discard.length > 1) {
                            const buried = G.discard.slice(0, -1);
                            G.deadCards = G.deadCards || [];
                            buried.forEach(c => { if (!G.deadCards.some(d => d.id === c.id)) G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild}); });
                        }
                        p.hand.push(G.discard.pop());
                        if (isNextPlayer) {
                            toast(p.name + ' took the discard!');
                            G.cur = G.buyer;
                            G.drawn = true;
                            G.phase = 'play';
                            G.buyer = -1;
                            G.buyQ = [];
                            cpuBuyingRunning = false;
                            sync();
                            setTimeout(() => { cpuBuyingRunning = false; cpuRunning = false; cpuPlayPhase(p); }, 800);
                        } else {
                            reshuffle();
                            if (G.deck.length) p.hand.push(G.deck.pop());
                            toast(p.name + ' bought! +1 penalty');
                            G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                            cpuBuyingRunning = false;
                            sync();
                            nextTurn();
                        }
                    } else {
                        cpuBuyingRunning = false;
                        nextBuyer();
                    }
                }, 800);
            }
        }

        function cpuPlayPhase(p) {
            const diff = G.difficulty || 'easy';
            if (!p.laid) {
                const tryLay = diff === 'hard' || diff === 'medium' || Math.random() < 0.3;
                if (tryLay) {
                    const contract = CONTRACTS[G.contract];
                    const result = detectMelds(p.hand, contract);
                    if (result) {
                        result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:p.name, oid:p.id}));
                        result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:p.name, oid:p.id}));
                        const usedCards = [...result.sets.flat(), ...result.runs.flat()];
                        p.hand = p.hand.filter(c => !usedCards.includes(c));
                        p.laid = true;
                        toast(p.name + ' laid down!');
                        sync();
                        if (isFinalContract() && !p.hand.length) { endRound(G.cur); return; }
                    }
                }
            }
            if (p.laid && G.melds.length && (diff === 'medium' || diff === 'hard')) {
                for (let i = p.hand.length - 1; i >= 0; i--) {
                    const card = p.hand[i];
                    for (const m of G.melds) {
                        const testCards = [...m.cards, card];
                        const valid = m.type === 'Set' ? validSet(testCards) : validRun(testCards);
                        if (valid) {
                            m.cards.push(card);
                            if (m.type === 'Run') m.cards.sort((a,b) => a.wild ? 1 : b.wild ? -1 : RANK_VAL[a.rank] - RANK_VAL[b.rank]);
                            p.hand.splice(i, 1);
                            toast(p.name + ' added to ' + m.type.toLowerCase());
                            sync();
                            if (isFinalContract() && !p.hand.length && p.laid) { endRound(G.cur); return; }
                            break;
                        }
                    }
                }
            }
            setTimeout(() => {
                if (!p.hand.length) { endRound(G.cur); return; }
                if (isFinalContract() && p.laid && p.hand.length === 1 && p.hand[0].wild) { endRound(G.cur); return; }
                let discIdx = 0;
                if (diff !== 'easy') {
                    const scores = p.hand.map((c, i) => {
                        if (c.wild) return { i, score: -100 };
                        const matchRank = p.hand.filter(x => x.rank === c.rank).length;
                        const matchSuit = p.hand.filter(x => x.suit === c.suit && !x.wild).length;
                        return { i, score: matchRank * 2 + matchSuit };
                    });
                    scores.sort((a, b) => a.score - b.score);
                    discIdx = scores[0].i;
                } else {
                    const nonWilds = p.hand.map((c, i) => ({ c, i })).filter(x => !x.c.wild);
                    if (nonWilds.length) discIdx = nonWilds[Math.floor(Math.random() * nonWilds.length)].i;
                }
                G.discard.push(p.hand[discIdx]);
                p.hand.splice(discIdx, 1);
                if (!p.hand.length && p.laid) { sync(); endRound(G.cur); return; }
                cpuRunning = false;
                sync();
                setTimeout(startBuying, 500);
            }, 800);
        }

        function cpuTurn() {
            const p = G.players[G.cur];
            if (!p?.cpu) return;
            const diff = G.difficulty || 'easy';
            const topDiscard = G.discard.length ? G.discard[G.discard.length - 1] : null;
            let takeDiscard = false;
            if (topDiscard && diff !== 'easy') {
                if (topDiscard.wild) takeDiscard = true;
                else {
                    const matchRank = p.hand.filter(c => c.rank === topDiscard.rank).length;
                    const matchSuit = p.hand.filter(c => c.suit === topDiscard.suit && !c.wild).length;
                    takeDiscard = diff === 'hard' ? (matchRank >= 2 || matchSuit >= 3) : matchRank >= 2;
                }
            }
            if (takeDiscard && G.discard.length) {
                if (G.discard.length > 1) {
                    const buried = G.discard.slice(0, -1);
                    G.deadCards = G.deadCards || [];
                    buried.forEach(c => { if (!G.deadCards.some(d => d.id === c.id)) G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild}); });
                }
                p.hand.push(G.discard.pop());
                toast(p.name + ' took discard');
            } else {
                reshuffle();
                if (G.deck.length) p.hand.push(G.deck.pop());
            }
            G.drawn = true;
            G.phase = 'play';
            sync();
            setTimeout(() => {
                if (!p.laid) {
                    const tryLay = diff === 'hard' || diff === 'medium' || Math.random() < 0.3;
                    if (tryLay) {
                        const contract = CONTRACTS[G.contract];
                        const result = detectMelds(p.hand, contract);
                        if (result) {
                            result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:p.name, oid:p.id}));
                            result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:p.name, oid:p.id}));
                            const usedCards = [...result.sets.flat(), ...result.runs.flat()];
                            p.hand = p.hand.filter(c => !usedCards.includes(c));
                            p.laid = true;
                            toast(p.name + ' laid down!');
                            sync();
                            if (isFinalContract() && !p.hand.length) { endRound(G.cur); return; }
                        }
                    }
                }
                if (p.laid && G.melds.length && (diff === 'medium' || diff === 'hard')) {
                    for (let i = p.hand.length - 1; i >= 0; i--) {
                        const card = p.hand[i];
                        for (const m of G.melds) {
                            if (canAdd([card], m)) { m.cards.push(card); p.hand.splice(i, 1); break; }
                        }
                    }
                    if (!p.hand.length && p.laid) { sync(); endRound(G.cur); return; }
                }
                if (!p.hand.length) { sync(); if (p.laid) endRound(G.cur); return; }
                let idx = 0;
                if (diff === 'easy') {
                    let high = -1;
                    p.hand.forEach((c, i) => { if (!c.wild) { const pts = POINTS[c.rank] || 5; if (pts > high) { high = pts; idx = i; } } });
                } else {
                    let minScore = Infinity;
                    p.hand.forEach((c, i) => {
                        if (c.wild) return;
                        let score = 0;
                        const matchRank = p.hand.filter(x => x.rank === c.rank).length;
                        const matchSuit = p.hand.filter(x => x.suit === c.suit && !x.wild).length;
                        score = matchRank * 10 + matchSuit * 5;
                        if (score < minScore) { minScore = score; idx = i; }
                    });
                }
                G.discard.push(p.hand.splice(idx, 1)[0]);
                if (!p.hand.length && p.laid) { sync(); endRound(G.cur); return; }
                render();
                toast(p.name + ' discarded');
                setTimeout(startBuying, 500);
            }, 1200);
        }

        function layDown() {
            if (!L.sel.length) return toast('Select cards');
            const me = getMe();
            const c = CONTRACTS[G.contract];
            const cards = L.sel.map(i => me.hand[i]);
            const result = detectMelds(cards, c);
            if (!result) return toast('Need ' + c.desc);
            result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:me.name, oid:me.id}));
            result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:me.name, oid:me.id}));
            [...L.sel].sort((a,b)=>b-a).forEach(i => me.hand.splice(i, 1));
            me.laid = true;
            L.sel = [];
            toast('Laid down!');
            if (isFinalContract() && !me.hand.length) { sync(); endRound(myIdx()); return; }
            if (!me.hand.length) { sync(); endRound(myIdx()); return; }
            sync();
        }

        function detectMelds(cards, contract) {
            const res = {sets:[], runs:[]};
            let rem = [...cards];
            const sameCard = (a, b) => a.rank === b.rank && a.suit === b.suit && a.wild === b.wild;
            const removeUsed = (remaining, used) => {
                const usedCopy = [...used];
                return remaining.filter(c => {
                    const idx = usedCopy.findIndex(u => sameCard(c, u));
                    if (idx >= 0) { usedCopy.splice(idx, 1); return false; }
                    return true;
                });
            };
            for (let i = 0; i < contract.runs; i++) {
                const run = findRun(rem);
                if (!run) return null;
                res.runs.push(run);
                rem = removeUsed(rem, run);
            }
            for (let i = 0; i < contract.sets; i++) {
                const set = findSet(rem);
                if (!set) return null;
                res.sets.push(set);
                rem = removeUsed(rem, set);
            }
            const isFinal = contract.runs === 3 && contract.sets === 0;
            if (isFinal) {
                if (rem.length === 0) {
                } else if (rem.length === 1 && !rem[0].wild) {
                } else { return null; }
            }
            return res;
        }

        function findSet(cards) {
            const wilds = cards.filter(c => c.wild);
            const byRank = {};
            cards.filter(c => !c.wild).forEach(c => { if (!byRank[c.rank]) byRank[c.rank] = []; byRank[c.rank].push(c); });
            const ranks = Object.keys(byRank).sort((a,b) => byRank[b].length - byRank[a].length);
            for (const r of ranks) {
                const nat = byRank[r];
                if (nat.length >= 3) return nat.slice(0, Math.min(4, nat.length));
                if (nat.length >= 1) {
                    const need = 3 - nat.length;
                    if (need <= wilds.length) return [...nat, ...wilds.slice(0, need)];
                }
            }
            return null;
        }

        function findRun(cards) {
            const wilds = cards.filter(c => c.wild);
            const bySuit = {};
            cards.filter(c => !c.wild).forEach(c => { if (!bySuit[c.suit]) bySuit[c.suit] = []; bySuit[c.suit].push(c); });
            for (const suit of SUITS) {
                if (!bySuit[suit] || bySuit[suit].length < 1) continue;
                const sc = bySuit[suit].sort((a,b) => RANK_VAL[a.rank] - RANK_VAL[b.rank]);
                for (let st = 0; st < sc.length; st++) {
                    let run = [sc[st]];
                    let aw = [...wilds];
                    let lastVal = RANK_VAL[sc[st].rank];
                    for (let j = st + 1; j < sc.length; j++) {
                        const nextVal = RANK_VAL[sc[j].rank];
                        const gap = nextVal - lastVal - 1;
                        if (gap === 0) { run.push(sc[j]); lastVal = nextVal; }
                        else if (gap > 0 && gap <= aw.length) { for (let g = 0; g < gap; g++) run.push(aw.shift()); run.push(sc[j]); lastVal = nextVal; }
                        else if (gap < 0) continue; else break;
                    }
                    while (run.length < 4 && aw.length > 0 && lastVal < 13) { run.push(aw.shift()); lastVal++; }
                    let firstVal = RANK_VAL[sc[st].rank];
                    while (run.length < 4 && aw.length > 0 && firstVal > 1) { run.unshift(aw.shift()); firstVal--; }
                    const naturals = run.filter(x => !x.wild).length;
                    if (run.length >= 4 && naturals >= 3) return run;
                }
            }
            return null;
        }

        function showAddModal() {
            if (!L.sel.length) return toast('Select cards');
            const me = getMe();
            const cards = L.sel.map(i => me.hand[i]);
            let html = '<p style="margin-bottom:15px;">Select a set or run:</p>';
            G.melds.forEach((m, i) => {
                const ok = canAdd(cards, m);
                html += `<div class="meld-option ${ok?'':'disabled'}" onclick="${ok?`addTo(${i})`:''}">
                    <div class="meld-option-title">${m.owner}'s ${m.type}</div>
                    <div class="meld-option-cards">${m.cards.map(c=>c.rank).join(', ')}</div>
                </div>`;
            });
            modal('Add to Set/Run', html, [{text:'Cancel', cls:'btn-secondary'}]);
        }

        function canAdd(cards, m) {
            const all = [...m.cards, ...cards];
            return m.type === 'Set' ? validSet(all) : validRun(all);
        }

        function validSet(cards) {
            if (cards.length < 3) return false;
            const nat = cards.filter(c => !c.wild);
            if (!nat.length) return false;
            const r = nat[0].rank;
            return nat.every(c => c.rank === r);
        }

        function validRun(cards) {
            if (cards.length < 4) return false;
            const nat = cards.filter(c => !c.wild);
            if (nat.length < 3) return false;
            const suit = nat[0].suit;
            if (!nat.every(c => c.suit === suit)) return false;
            const sorted = [...nat].sort((a,b) => RANK_VAL[a.rank] - RANK_VAL[b.rank]);
            const min = RANK_VAL[sorted[0].rank], max = RANK_VAL[sorted[sorted.length-1].rank];
            if (max - min + 1 > cards.length) return false;
            const ranks = new Set(sorted.map(c => c.rank));
            return ranks.size === sorted.length;
        }

        function addTo(i) {
            closeModal();
            const me = getMe();
            const m = G.melds[i];
            const cards = L.sel.map(x => me.hand[x]);
            if (!canAdd(cards, m)) return toast("Can't add");
            cards.forEach(c => m.cards.push(c));
            if (m.type === 'Run') m.cards.sort((a,b) => a.wild ? 1 : b.wild ? -1 : RANK_VAL[a.rank] - RANK_VAL[b.rank]);
            [...L.sel].sort((a,b)=>b-a).forEach(x => me.hand.splice(x, 1));
            L.sel = [];
            toast('Added!');
            if (isFinalContract() && !me.hand.length && me.laid) { sync(); endRound(myIdx()); return; }
            if (!me.hand.length && me.laid) { sync(); endRound(myIdx()); return; }
            sync();
        }

        function endRound(wi) {
            cpuRunning = false;
            cpuBuyingRunning = false;
            const winner = G.players[wi];
            analytics.roundsPlayed++;
            trackStat('roundWins', winner.name);
            const pointsAdded = {};
            G.players.forEach((p, i) => {
                if (i !== wi) { const pts = p.hand.reduce((s, c) => s + (POINTS[c.rank] || 5), 0); p.score += pts; pointsAdded[p.name] = pts; }
                else { pointsAdded[p.name] = 0; }
            });
            if (isLastContract()) { showFinal(); return; }
            const sorted = [...G.players].sort((a,b) => a.score - b.score);
            let analyticsHtml = `
                <div class="analytics-container">
                    <div class="analytics-title">üìä Round ${analytics.roundsPlayed} Summary</div>
                    ${sorted.map((p, i) => {
                        const prob = calculateWinProbability(p, G.players);
                        const probClass = prob >= 50 ? 'prob-high' : prob >= 25 ? 'prob-med' : 'prob-low';
                        const roundWins = analytics.roundWins[p.name] || 0;
                        const isWinner = p.name === winner.name;
                        return `
                            <div class="player-stats-row ${isWinner ? 'winner' : ''}">
                                <div class="player-stats-name">${isWinner ? 'üëë ' : ''}${p.name}</div>
                                <div>
                                    <span class="player-stats-score">${p.score} pts</span>
                                    <span style="color:${pointsAdded[p.name] > 0 ? 'var(--danger)' : 'var(--success)'};font-size:0.8rem;margin-left:5px;">${pointsAdded[p.name] > 0 ? '+' + pointsAdded[p.name] : '‚úì'}</span>
                                </div>
                                <div class="player-stats-prob ${probClass}">${prob}% win</div>
                            </div>
                        `;
                    }).join('')}
                    <div class="analytics-grid" style="margin-top:15px;">
                        <div class="analytics-stat"><div class="analytics-value">${analytics.roundsPlayed}/${CONTRACTS.length}</div><div class="analytics-label">Contracts Done</div></div>
                        <div class="analytics-stat"><div class="analytics-value">${analytics.roundWins[winner.name] || 1}</div><div class="analytics-label">${winner.name}'s Rounds</div></div>
                    </div>
                </div>
                <p style="margin-top:15px;text-align:center;">Next: <strong>Contract ${G.contract + 2}</strong> - ${CONTRACTS[G.contract + 1].desc}</p>
            `;
            modal('üéâ ' + winner.name + ' wins the round!', analyticsHtml, [{text:'Continue', cls:'btn-success', fn:nextContract}]);
        }

        function nextContract() {
            cpuRunning = false; cpuBuyingRunning = false; G.contract++;
            const c = CONTRACTS[G.contract];
            G.melds = []; G.deadCards = [];
            G.players.forEach(p => { p.hand = []; p.laid = false; });
            G.deck = makeDeck(numDecks(G.players.length));
            G.discard = [];
            for (let i = 0; i < c.cards; i++) G.players.forEach(p => p.hand.push(G.deck.pop()));
            G.discard.push(G.deck.pop());
            G.cur = 0; G.drawn = false; G.phase = 'draw'; L.sel = [];
            sync();
            if (G.players[0].cpu) setTimeout(() => { cpuRunning = false; cpuTurn(); }, 1000);
        }

        function createConfetti() {
            const container = document.getElementById('win-confetti');
            container.innerHTML = '';
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${Math.random() * 3 + 2}s linear forwards`;
                confetti.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(confetti);
            }
        }

        function showFinal() {
            const sorted = [...G.players].sort((a,b) => a.score - b.score);
            const winner = sorted[0];
            const isHumanWinner = winner.human && !winner.cpu;
            analytics.roundsPlayed++; trackStat('roundWins', winner.name);
            if (isHumanWinner) {
                const overlay = document.getElementById('win-overlay');
                document.getElementById('win-title').textContent = winner.name.toUpperCase() + ' WINS!';
                document.getElementById('win-subtitle').textContent = gameMode === 'quick' ? 'Quick Rummy Champion!' : 'Liverpool Rummy Champion!';
                overlay.classList.add('active');
                createConfetti();
                if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
                setTimeout(() => { overlay.classList.remove('active'); showFinalModal(sorted, winner); }, 4000);
            } else { showFinalModal(sorted, winner); }
        }

        function showFinalModal(sorted, winner) {
            const totalPoints = sorted.reduce((sum, p) => sum + p.score, 0);
            const html = `
                <div class="analytics-container">
                    <div class="analytics-title">üèÅ Final Standings</div>
                    ${sorted.map((p, i) => {
                        const isWinner = i === 0;
                        return `
                            <div class="player-stats-row ${isWinner ? 'winner' : ''}">
                                <div class="player-stats-name">${isWinner ? 'üèÜ ' : i === 1 ? 'ü•à ' : i === 2 ? 'ü•â ' : (i+1) + '. '}${p.name}</div>
                                <div class="player-stats-score">${p.score} pts</div>
                            </div>`;
                    }).join('')}
                </div>
                <div class="analytics-container">
                    <div class="analytics-title">üìä Game Statistics</div>
                    <div class="analytics-grid">
                        <div class="analytics-stat"><div class="analytics-value">${CONTRACTS.length}</div><div class="analytics-label">Contracts Played</div></div>
                        <div class="analytics-stat"><div class="analytics-value">${totalPoints}</div><div class="analytics-label">Total Points</div></div>
                        <div class="analytics-stat"><div class="analytics-value">${sorted[0].score}</div><div class="analytics-label">Winning Score</div></div>
                        <div class="analytics-stat"><div class="analytics-value">${sorted[sorted.length-1].score - sorted[0].score}</div><div class="analytics-label">Point Spread</div></div>
                    </div>
                </div>`;
            modal('üéä Game Over!', html, [{text:'Back to Menu', cls:'btn-primary', fn:() => { if (L.isOnline) leaveRoom(); else showScreen('title-screen'); }}]);
        }

        function showRules() {
            modal('How to Play', `
                <div style="text-align:left;font-size:0.9rem;line-height:1.6;">
                    <p><strong>Goal:</strong> Complete all contracts with lowest score.</p><br>
                    <p><strong>üÉè Classic Mode (7 Contracts):</strong></p>
                    <ol style="margin-left:20px;margin-bottom:10px;font-size:0.85rem;">
                        <li>2 Sets</li><li>1 Set + 1 Run</li><li>2 Runs</li><li>3 Sets</li><li>2 Sets + 1 Run</li><li>1 Set + 2 Runs</li><li>3 Runs (all cards)</li>
                    </ol>
                    <p><strong>‚ö° Quick Rummy (4 Contracts):</strong></p>
                    <ol style="margin-left:20px;margin-bottom:15px;font-size:0.85rem;">
                        <li>2 Sets</li><li>2 Runs</li><li>3 Sets</li><li>3 Runs (all cards)</li>
                    </ol>
                    <p><strong>Set:</strong> 3+ same rank (need 1 natural)</p>
                    <p><strong>Run:</strong> 4+ consecutive same suit (need 3 natural)</p><br>
                    <p><strong>Wilds:</strong> All 2s and Jokers</p><br>
                    <p><strong>Taking/Buying Discards:</strong></p>
                    <p style="margin-left:10px;color:var(--text-muted);">When someone discards, the <strong>next player gets first dibs FREE</strong> - they can take it and it becomes their turn (they still discard at end). If they pass, others can <strong>buy</strong> it in turn order (+1 penalty card). If everyone passes, next player's turn begins normally.</p><br>
                    <p><strong>Dead Cards:</strong></p>
                    <p style="margin-left:10px;color:var(--text-muted);">Cards buried in the discard pile are "dead" (üíÄ). Dead cards cannot be picked up or bought.</p>
                </div>
            `, [{text:'Got it!', cls:'btn-primary'}]);
        }
    </script>
</body>
</html>

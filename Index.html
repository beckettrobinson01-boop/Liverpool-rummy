<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-touch-fullscreen" content="yes">
    <meta name="apple-mobile-web-app-title" content="Liverpool Rummy">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="theme-color" content="#1A237E">
    <link rel="manifest" href="manifest.json">
    <link rel="apple-touch-icon" href="icon-180.png">
    <title>Liverpool Rummy</title>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700;800&display=swap" rel="stylesheet">
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
    <style>
        :root {
            --primary: #8B1E3F;
            --primary-dark: #61152D;
            --success: #2E7D32;
            --danger: #B22222;
            --warning: #D4AF37;
            --bg: #0C3A1F;
            --card-bg: #154427;
            --card-hover: #1E5532;
            --text: #F5F1E5;
            --text-muted: #C7C2B5;
            --hearts: #B22222;
            --diamonds: #1E88E5;
            --clubs: #2E7D32;
            --spades: #1C1C1C;
            --wild: #7B1FA2;
            --radius: 20px;
            --yellow-card: #E0C066;
            --green-card: #2E7D32;
            --blue-card: #1E88E5;
            --red-card: #B22222;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Poppins', sans-serif;
            background: radial-gradient(circle at 20% 20%, rgba(255,255,255,0.05), transparent 25%), radial-gradient(circle at 80% 0%, rgba(255,255,255,0.05), transparent 20%), linear-gradient(180deg, var(--bg), #0a2c18);
            min-height: 100vh;
            color: var(--text);
            overflow-x: hidden;
            overscroll-behavior: none;
        }

        .screen { display: none; min-height: 100vh; padding: 20px; animation: fadeIn 0.3s ease; }
        .screen.active { display: flex; flex-direction: column; }
        @keyframes fadeIn { from { opacity: 0; transform: scale(0.95); } to { opacity: 1; transform: scale(1); } }

        .container { max-width: 500px; width: 100%; margin: 0 auto; }

        .btn {
            display: inline-flex; align-items: center; justify-content: center; gap: 10px;
            padding: 18px 32px; font-family: inherit; font-size: 1.1rem; font-weight: 700;
            border: none; border-radius: var(--radius); cursor: pointer; transition: all 0.2s; width: 100%;
            text-transform: uppercase; letter-spacing: 1px;
        }
        .btn-primary { background: linear-gradient(135deg, var(--primary), var(--primary-dark)); color: white; box-shadow: 0 4px 12px rgba(97,21,45,0.35); }
        .btn-primary:hover { transform: translateY(-2px) scale(1.01); box-shadow: 0 6px 16px rgba(97,21,45,0.45); }
        .btn-success { background: linear-gradient(135deg, #2E7D32, #1f5a23); color: white; box-shadow: 0 3px 10px rgba(46,125,50,0.3); }
        .btn-danger { background: linear-gradient(135deg, #B22222, #7d1616); color: white; box-shadow: 0 3px 10px rgba(178,34,34,0.3); }
        .btn-secondary { background: var(--card-bg); color: var(--text); border: 3px solid var(--warning); }
        .btn-secondary:hover { background: var(--card-hover); transform: scale(1.02); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none !important; }
        .btn-sm { padding: 12px 20px; font-size: 0.95rem; }

        /* Title Screen */
        #title-screen { justify-content: center; align-items: center; text-align: center; background: linear-gradient(180deg, var(--bg), #0D47A1); }
        .logo { margin-bottom: 60px; animation: logoFloat 3s ease-in-out infinite; }
        @keyframes logoFloat { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-10px); } }
        .logo h1 { font-size: clamp(3rem, 12vw, 5rem); font-weight: 900; background: linear-gradient(135deg, #F44336, #FF9800, #FFEB3B, #4CAF50, #2196F3); -webkit-background-clip: text; -webkit-text-fill-color: transparent; text-shadow: none; letter-spacing: -2px; }
        .logo p { color: var(--warning); font-size: 1.2rem; font-weight: 700; text-transform: uppercase; letter-spacing: 3px; margin-top: 10px; }
        .menu-buttons { display: flex; flex-direction: column; gap: 16px; width: 100%; max-width: 320px; }

        /* Setup Screens */
        .setup-screen { justify-content: flex-start; padding-top: 60px; }
        .back-btn { position: absolute; top: 20px; left: 20px; background: var(--card-bg); border: none; color: var(--text); width: 48px; height: 48px; border-radius: 50%; font-size: 1.5rem; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        .back-btn:hover { background: var(--card-hover); }
        .setup-title { font-size: 1.8rem; font-weight: 700; text-align: center; margin-bottom: 40px; }
        .form-group { margin-bottom: 24px; }
        .form-label { display: block; font-size: 0.95rem; font-weight: 600; color: var(--text-muted); margin-bottom: 10px; }
        .form-input { width: 100%; padding: 16px 20px; font-family: inherit; font-size: 1.1rem; background: var(--card-bg); border: 2px solid var(--card-hover); border-radius: var(--radius); color: var(--text); }
        .form-input:focus { outline: none; border-color: var(--primary); }
        .form-input::placeholder { color: var(--text-muted); }

        .option-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 10px; }
        .option-btn { padding: 16px; font-family: inherit; font-size: 1.2rem; font-weight: 700; background: var(--card-bg); border: 3px solid var(--card-hover); border-radius: var(--radius); color: var(--text); cursor: pointer; transition: all 0.2s; }
        .option-btn:hover { border-color: var(--primary); }
        .option-btn.selected { background: var(--primary); border-color: var(--primary); transform: scale(1.05); }

        .diff-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 10px; }
        .diff-btn { padding: 14px; font-family: inherit; font-size: 0.95rem; font-weight: 600; background: var(--card-bg); border: 3px solid var(--card-hover); border-radius: var(--radius); color: var(--text); cursor: pointer; }
        .diff-btn.selected.easy { background: var(--success); border-color: var(--success); }
        .diff-btn.selected.medium { background: var(--warning); border-color: var(--warning); color: #000; }
        .diff-btn.selected.hard { background: var(--danger); border-color: var(--danger); }

        /* Game Mode Cards */
        .mode-cards { display: flex; flex-direction: column; gap: 20px; max-width: 400px; margin: 0 auto; }
        .mode-card { background: linear-gradient(135deg, var(--card-bg), #1565C0); border: 3px solid var(--card-hover); border-radius: var(--radius); padding: 25px; cursor: pointer; transition: all 0.3s ease; text-align: center; }
        .mode-card:hover { border-color: var(--warning); transform: translateY(-5px); box-shadow: 0 10px 30px rgba(0,0,0,0.3); }
        .mode-card:active { transform: translateY(-2px); }
        .mode-icon { font-size: 3rem; margin-bottom: 10px; }
        .mode-title { font-size: 1.5rem; font-weight: 800; color: var(--warning); margin-bottom: 5px; }
        .mode-desc { font-size: 1rem; color: var(--text); margin-bottom: 10px; }
        .mode-contracts { font-size: 0.8rem; color: var(--text-muted); padding: 10px; background: rgba(0,0,0,0.2); border-radius: 10px; }

        /* Lobby */
        .room-code-box { background: var(--card-bg); border-radius: var(--radius); padding: 30px; text-align: center; margin-bottom: 30px; }
        .room-code-label { font-size: 0.95rem; color: var(--text-muted); margin-bottom: 10px; }
        .room-code { font-size: 3rem; font-weight: 800; letter-spacing: 0.3em; color: var(--warning); }
        .players-list { background: var(--card-bg); border-radius: var(--radius); padding: 20px; margin-bottom: 20px; }
        .players-list-title { font-size: 0.9rem; color: var(--text-muted); margin-bottom: 15px; font-weight: 600; }
        .player-row { display: flex; align-items: center; justify-content: space-between; padding: 12px 16px; background: var(--bg); border-radius: 10px; margin-bottom: 8px; }
        .player-row:last-child { margin-bottom: 0; }
        .player-name { font-weight: 600; display: flex; align-items: center; gap: 8px; }
        .badge { font-size: 0.75rem; padding: 4px 10px; border-radius: 20px; font-weight: 700; }
        .badge-host { background: var(--warning); color: #000; }
        .badge-cpu { background: var(--wild); color: #fff; }
        .badge-you { background: var(--primary); color: #fff; }
        .remove-btn { background: var(--danger); border: none; color: white; width: 28px; height: 28px; border-radius: 50%; cursor: pointer; font-size: 1rem; }

        /* Game Screen */
        #game-screen { padding: calc(10px + env(safe-area-inset-top, 0px)) 10px 12px; background: linear-gradient(180deg, var(--bg), #0a2c18); }
        .game-header { display: flex; justify-content: space-between; align-items: center; padding: 15px 20px; background: linear-gradient(135deg, var(--card-bg), #1565C0); border-radius: var(--radius); margin-bottom: 12px; border: 2px solid var(--warning); }
        .contract-info { text-align: left; }
        .contract-num { font-size: 0.85rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .contract-desc { font-size: 1.2rem; font-weight: 800; color: var(--warning); text-shadow: 1px 1px 2px rgba(0,0,0,0.3); }
        .game-stats { text-align: right; font-size: 0.9rem; color: var(--text-muted); }
        .game-stats div { margin-bottom: 2px; }
        .header-actions { display: flex; align-items: center; gap: 10px; }
        .sound-btn {
            width: 42px; height: 42px;
            border-radius: 50%;
            border: 2px solid var(--warning);
            background: var(--card-hover);
            color: var(--warning);
            font-size: 1.2rem;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            box-shadow: 0 4px 12px rgba(0,0,0,0.25);
        }
        .sound-btn:hover { transform: translateY(-2px) scale(1.05); background: var(--card-bg); }
        .sound-btn:active { transform: translateY(0); }
        /* Tutorial tip */
        .tutorial-tip {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            max-width: 520px;
            width: calc(100% - 30px);
            background: rgba(0,0,0,0.7);
            border: 2px solid var(--warning);
            color: #fff;
            padding: 14px 16px;
            border-radius: 14px;
            display: none;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            z-index: 1200;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        .tutorial-tip.active { display: flex; }
        .tutorial-text { font-size: 0.95rem; line-height: 1.4; }
        .tutorial-controls { display: flex; gap: 8px; }
        .tutorial-btn { padding: 8px 14px; border-radius: 10px; border: 2px solid var(--warning); background: rgba(0,0,0,0.3); color: var(--warning); font-weight: 700; cursor: pointer; }
        
        /* Guide (Clippy) */
        .clippy {
            position: fixed;
            bottom: 16px;
            right: 16px;
            display: flex;
            gap: 10px;
            align-items: center;
            background: rgba(0,0,0,0.75);
            color: var(--text);
            padding: 12px 14px;
            border-radius: 14px;
            border: 2px solid var(--warning);
            max-width: 260px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.4);
            z-index: 1300;
            backdrop-filter: blur(4px);
        }
        .clippy.hidden { display: none; }
        .clippy-avatar {
            width: 42px; height: 42px;
            border-radius: 50%;
            background: var(--card-hover);
            border: 2px solid var(--warning);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.2rem;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.2);
        }
        .clippy-text { flex: 1; font-size: 0.9rem; line-height: 1.3; }
        .clippy-actions { display: flex; gap: 6px; }
        .clippy-btn { border: 1px solid var(--warning); background: rgba(0,0,0,0.3); color: var(--warning); border-radius: 10px; padding: 4px 8px; font-size: 0.8rem; cursor: pointer; }

        .turn-indicator { text-align: center; padding: 18px; background: var(--card-bg); border-radius: var(--radius); margin-bottom: 12px; font-weight: 700; font-size: 1.1rem; border: 3px solid transparent; }
        .turn-indicator.your-turn { background: linear-gradient(135deg, var(--success), #2E7D32); color: white; animation: turnPulse 1.5s infinite; border-color: #81C784; }
        .turn-indicator.waiting { color: var(--text-muted); background: var(--card-bg); }
        @keyframes turnPulse { 0%, 100% { box-shadow: 0 0 0 0 rgba(76,175,80,0.6); transform: scale(1); } 50% { box-shadow: 0 0 20px 5px rgba(76,175,80,0.3); transform: scale(1.02); } }
        .cpu-status { text-align:center; font-size:0.9rem; color: var(--text-muted); margin-bottom: 6px; }
        .cpu-status.active { color: var(--warning); }

        .opponents-row { display: flex; gap: 12px; overflow-x: auto; padding: 12px 5px; margin-bottom: 12px; justify-content: center; flex-wrap: wrap; }
        .opponent-card { flex-shrink: 0; background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 15px 20px; min-width: 120px; text-align: center; border: 3px solid transparent; transition: all 0.3s ease; }
        .opponent-card.active { border-color: var(--warning); box-shadow: 0 0 20px rgba(255,193,7,0.4); animation: activeGlow 1s infinite; }
        @keyframes activeGlow { 0%, 100% { box-shadow: 0 0 15px rgba(255,193,7,0.4); } 50% { box-shadow: 0 0 30px rgba(255,193,7,0.6); } }
        .opponent-name { font-weight: 700; font-size: 0.9rem; margin-bottom: 6px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .opponent-cards { font-size: 2rem; font-weight: 900; color: var(--warning); text-shadow: 2px 2px 4px rgba(0,0,0,0.3); }
        .opponent-status { font-size: 0.8rem; color: var(--text-muted); margin-top: 4px; }
        .laid-badge { font-size: 0.7rem; background: linear-gradient(135deg, var(--success), #2E7D32); color: white; padding: 4px 10px; border-radius: 12px; margin-top: 6px; display: inline-block; font-weight: 700; }

        .table-area { display: flex; justify-content: center; gap: 40px; padding: 22px; margin-bottom: 10px; }
        .pile { text-align: center; }
        .pile-label { font-size: 0.9rem; color: var(--warning); margin-bottom: 10px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .pile-cards { position: relative; width: 85px; height: 120px; }

        .card { width: 85px; height: 120px; border-radius: 16px; display: flex; flex-direction: column; align-items: center; justify-content: center; font-weight: 800; cursor: pointer; transition: all 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275); user-select: none; -webkit-user-select: none; -webkit-touch-callout: none; position: relative; overflow: hidden; touch-action: manipulation; }
        .touch .card { width: 72px; height: 102px; }
        .touch .pile-cards { width: 72px; height: 102px; }
        .touch .hand-cards { gap: 8px; }
        .touch .table-area { gap: 22px; padding: 10px; }
        .touch #game-screen { padding: 6px 8px; }
        .touch .hand-cards { min-height: 120px; }
        .card-back { background: linear-gradient(135deg, #FF5722, #E64A19); border: 4px solid rgba(255,255,255,0.3); box-shadow: 0 4px 15px rgba(0,0,0,0.3); }
        .card-back::before { content: ''; position: absolute; inset: 8px; border: 3px solid rgba(255,255,255,0.2); border-radius: 10px; }
        .card-back::after { content: 'üé¥'; font-size: 2.5rem; opacity: 0.5; }
        .card-front { background: #fdfaf5; border: 4px solid #2b2b2b; color: #2b2b2b; box-shadow: 0 4px 15px rgba(0,0,0,0.2); }
        .card-front.hearts { background: linear-gradient(180deg, #fdfaf5 0%, #f7e3e0 100%); color: #B22222; border-color: #B22222; }
        .card-front.diamonds { background: linear-gradient(180deg, #fdfaf5 0%, #e3e8f7 100%); color: #1E88E5; border-color: #1E88E5; }
        .card-front.clubs { background: linear-gradient(180deg, #fdfaf5 0%, #e3f2e8 100%); color: #2E7D32; border-color: #2E7D32; }
        .card-front.spades { background: linear-gradient(180deg, #fdfaf5 0%, #ededed 100%); color: #1C1C1C; border-color: #1C1C1C; }
        .card-front.wild { background: linear-gradient(135deg, #6a1b9a, #7B1FA2, #9C27B0); color: #fdfaf5; border-color: #D4AF37; animation: wildPulse 2s ease-in-out infinite; }
        @keyframes wildPulse { 0%, 100% { box-shadow: 0 0 10px #9C27B0; } 50% { box-shadow: 0 0 25px #E91E63, 0 0 35px #9C27B0; } }
        
        /* Custom Joker Card */
        .card-front.joker-custom { 
            background-size: cover; 
            background-position: center top;
            border: 4px solid #FFD700; 
        }
        .card-front.joker-custom .card-rank { 
            font-size: 2.5rem; 
            color: white; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), -2px -2px 4px rgba(0,0,0,0.9); 
            z-index: 2;
        }
        .card-front.joker-custom .card-suit { display: none; }
        
        /* Custom Queen Card */
        .card-front.queen-custom { 
            background-size: cover; 
            background-position: center top;
            border: 4px solid gold; 
        }
        .card-front.queen-custom .card-rank { 
            font-size: 2.5rem; 
            color: white; 
            text-shadow: 3px 3px 6px rgba(0,0,0,0.9), -2px -2px 4px rgba(0,0,0,0.9); 
            z-index: 2;
        }
        .card-front.queen-custom .card-suit { 
            font-size: 1.4rem;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.9);
            z-index: 2;
        }
        
        .card-rank { font-size: 1.8rem; line-height: 1; font-weight: 900; }
        .card-suit { font-size: 2rem; line-height: 1; }
        .card:hover:not(.card-back) { transform: translateY(-8px) scale(1.05); box-shadow: 0 15px 30px rgba(0,0,0,0.3); }
        .card.selected { transform: translateY(-25px) scale(1.1); box-shadow: 0 20px 40px rgba(255,87,34,0.5); border-color: var(--warning) !important; animation: selectedBounce 0.5s ease; }
        .touch .card.selected { transform: translateY(-12px) scale(1.04); }
        .card.selected::after {
            content: '‚úì';
            position: absolute;
            top: 6px;
            right: 6px;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--warning);
            color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 900;
            box-shadow: 0 0 0 2px rgba(0,0,0,0.3);
        }
        @keyframes selectedBounce { 0% { transform: translateY(0) scale(1); } 50% { transform: translateY(-30px) scale(1.15); } 100% { transform: translateY(-25px) scale(1.1); } }
        .deck-pile .card-back:hover { transform: scale(1.08) rotate(-2deg); }
        .deck-count { position: absolute; bottom: -28px; left: 50%; transform: translateX(-50%); font-size: 0.85rem; color: var(--warning); font-weight: 700; }
        
        .melds-area { background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 18px; margin-bottom: 12px; min-height: 60px; border: 2px solid rgba(255,255,255,0.1); }
        .melds-title { font-size: 0.9rem; color: var(--warning); margin-bottom: 12px; font-weight: 700; text-transform: uppercase; letter-spacing: 1px; }
        .melds-container { display: flex; flex-wrap: wrap; gap: 18px; justify-content: center; }
        .meld-group { background: rgba(0,0,0,0.2); border-radius: 14px; padding: 12px; border: 2px solid rgba(255,255,255,0.1); }
        .meld-label { font-size: 0.75rem; color: var(--text-muted); margin-bottom: 8px; font-weight: 600; }
        .meld-cards { display: flex; }
        .meld-cards .card { width: 50px; height: 72px; margin-left: -15px; font-size: 0.85rem; border-width: 3px; }
        .meld-cards .card:first-child { margin-left: 0; }
        .meld-cards .card-rank { font-size: 1.1rem; }
        .meld-cards .card-suit { font-size: 1.2rem; }

        .hand-area { background: linear-gradient(180deg, var(--card-bg), #0f2f1b); border-radius: var(--radius) var(--radius) 0 0; padding: 18px; margin: 0 -10px calc(-10px + env(safe-area-inset-bottom, 0px)); border-top: 3px solid var(--warning); }
        .hand-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px; flex-wrap: wrap; gap: 10px; }
        .hand-title { font-weight: 700; font-size: 1.1rem; color: var(--warning); }
        .hand-controls { display: flex; gap: 8px; }
        .selection-badge { background: rgba(0,0,0,0.4); color: var(--warning); padding: 6px 10px; border-radius: 10px; font-weight: 700; border: 2px solid rgba(255,255,255,0.2); }
        .sort-btn { background: rgba(255,255,255,0.1); border: 2px solid var(--warning); color: var(--warning); padding: 8px 14px; border-radius: 10px; font-size: 0.85rem; cursor: pointer; font-family: inherit; font-weight: 700; transition: all 0.2s; }
        .sort-btn:hover { background: var(--warning); color: #000; }
        .sort-btn:disabled { opacity: 0.3; cursor: not-allowed; }
        .hand-cards { display: flex; flex-wrap: wrap; gap: 10px; justify-content: center; padding: 12px 0; min-height: 140px; position: relative; }
        
        /* Drag and drop */
        .card.dragging { opacity: 0.5; transform: scale(1.1); z-index: 100; }
        .card.drag-over { border: 3px dashed var(--warning) !important; }

        /* Dead card full overlay */
        .card-dead-overlay {
            position: absolute;
            inset: 0;
            background: rgba(0, 0, 0, 0.85);
            border-radius: inherit;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2.5rem;
            z-index: 10;
            color: #fff;
            animation: skullPop 0.25s ease;
        }
        .meld-cards .card-dead-overlay {
            font-size: 1.5rem;
        }
        @keyframes skullPop {
            0% { transform: scale(0.6); opacity: 0; }
            60% { transform: scale(1.15); opacity: 1; }
            100% { transform: scale(1); opacity: 1; }
        }
        .card.dead-card {
            opacity: 0.7;
            cursor: not-allowed !important;
        }
        .card.dead-card:hover {
            transform: none !important;
        }

        /* Global motion polish */
        body {
            background-size: 300% 300%;
            animation: bgShift 18s ease infinite;
        }
        @keyframes bgShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }
        .btn:active { transform: translateY(1px) scale(0.99); }
        .mode-card { animation: cardFloat 8s ease-in-out infinite; }
        .pile .card { animation: cardFloat 7s ease-in-out infinite; }
        .card-appear { animation: cardAppear 0.28s ease; }
        .card:hover:not(.card-back) { animation: cardHover 0.4s ease; }
        @keyframes cardAppear {
            0% { transform: translateY(12px) scale(0.96); opacity: 0; }
            70% { transform: translateY(-4px) scale(1.04); opacity: 1; }
            100% { transform: translateY(0) scale(1); opacity: 1; }
        }
        @keyframes cardFloat {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-6px); }
        }
        @keyframes cardHover {
            0% { box-shadow: 0 0 0 rgba(0,0,0,0); }
            100% { box-shadow: 0 15px 30px rgba(0,0,0,0.3); }
        }

        .action-bar { display: flex; gap: 12px; margin-top: 18px; }
        .action-btn { flex: 1; padding: 16px; font-family: inherit; font-size: 1rem; font-weight: 800; border: none; border-radius: 12px; cursor: pointer; text-transform: uppercase; letter-spacing: 1px; transition: all 0.2s; box-shadow: 0 4px 12px rgba(0,0,0,0.25); }
        .action-btn:disabled { opacity: 0.3; cursor: not-allowed; transform: none !important; }
        .action-btn:not(:disabled):hover { transform: translateY(-3px); }
        .btn-laydown { background: linear-gradient(135deg, var(--success), #2E7D32); color: white; box-shadow: 0 4px 15px rgba(76,175,80,0.4); }
        .btn-addto { background: linear-gradient(135deg, #2196F3, #1565C0); color: white; box-shadow: 0 4px 15px rgba(33,150,243,0.4); }
        .btn-discard { background: linear-gradient(135deg, var(--danger), #C62828); color: white; box-shadow: 0 4px 15px rgba(244,67,54,0.4); }

        /* Modal */
        .modal-overlay { display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; background: rgba(0,0,0,0.9); z-index: 1000; align-items: center; justify-content: center; padding: 20px; }
        .modal-overlay.active { display: flex; animation: modalFadeIn 0.3s ease; }
        @keyframes modalFadeIn { from { opacity: 0; } to { opacity: 1; } }
        .modal { background: linear-gradient(180deg, var(--card-bg), #1565C0); border-radius: var(--radius); padding: 30px; max-width: 420px; width: 100%; max-height: 80vh; overflow-y: auto; border: 3px solid var(--warning); animation: modalSlideIn 0.3s ease; }
        @keyframes modalSlideIn { from { transform: scale(0.8) translateY(20px); opacity: 0; } to { transform: scale(1) translateY(0); opacity: 1; } }
        .modal-title { font-size: 1.5rem; font-weight: 800; margin-bottom: 20px; text-align: center; color: var(--warning); }
        .modal-body { margin-bottom: 25px; }
        .modal-buttons { display: flex; flex-direction: column; gap: 10px; }
        .buy-card-display { display: flex; justify-content: center; margin: 20px 0; }
        .buy-card-display .card { width: 90px; height: 130px; }
        .buy-card-display .card-rank { font-size: 1.8rem; }
        .buy-card-display .card-suit { font-size: 2rem; }
        .buy-info { text-align: center; color: var(--text-muted); font-size: 0.95rem; }
        .meld-option { background: var(--bg); border: 2px solid var(--card-hover); border-radius: 10px; padding: 15px; margin-bottom: 10px; cursor: pointer; }
        .meld-option:hover { border-color: var(--primary); }
        .meld-option.disabled { opacity: 0.4; cursor: not-allowed; pointer-events: none; }
        .meld-option-title { font-weight: 600; margin-bottom: 5px; }
        .meld-option-cards { font-size: 0.9rem; color: var(--text-muted); }

        /* Buy Banner - shows at top instead of blocking modal */
        .buy-banner { display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, var(--warning), #D97706); padding: 20px; z-index: 500; box-shadow: 0 4px 20px rgba(0,0,0,0.3); }
        .buy-banner.active { display: block; animation: slideDown 0.3s ease; }
        @keyframes slideDown { from { transform: translateY(-100%); } to { transform: translateY(0); } }
        .buy-banner-content { max-width: 500px; margin: 0 auto; }
        .buy-banner-top { display: flex; align-items: center; justify-content: center; gap: 20px; margin-bottom: 15px; }
        .buy-banner-card { width: 60px; height: 85px; border-radius: 10px; display: flex; flex-direction: column; align-items: center; justify-content: center; background: white; border: 3px solid #ccc; font-weight: 700; font-size: 1.1rem; flex-shrink: 0; }
        .buy-banner-card.hearts, .buy-banner-card.diamonds { color: var(--hearts); }
        .buy-banner-card.clubs, .buy-banner-card.spades { color: #1a1a1a; }
        .buy-banner-card.wild { background: linear-gradient(135deg, var(--wild), #7C3AED); color: white; border-color: var(--wild); }
        .buy-banner-text { color: #000; text-align: center; }
        .buy-banner-title { font-weight: 800; font-size: 1.2rem; margin-bottom: 4px; }
        .buy-banner-subtitle { font-size: 0.85rem; opacity: 0.8; }
        .buy-banner-buttons { display: flex; gap: 12px; justify-content: center; }
        .buy-banner-btn { padding: 14px 28px; border: none; border-radius: 10px; font-family: inherit; font-weight: 700; font-size: 1rem; cursor: pointer; min-width: 100px; }
        .buy-btn-yes { background: var(--success); color: white; }
        .buy-btn-yes:hover { background: #059669; }
        .buy-btn-no { background: rgba(0,0,0,0.2); color: #000; }
        .buy-btn-no:hover { background: rgba(0,0,0,0.3); }
        
        /* Waiting for buyers indicator */
        .buy-waiting { display: none; position: fixed; top: 0; left: 0; right: 0; background: var(--card-bg); padding: 15px 20px; z-index: 500; border-bottom: 3px solid var(--warning); }
        .buy-waiting.active { display: block; animation: slideDown 0.3s ease; }
        .buy-waiting-content { max-width: 500px; margin: 0 auto; text-align: center; }
        .buy-waiting-title { font-weight: 700; color: var(--warning); margin-bottom: 5px; }
        .buy-waiting-detail { font-size: 0.9rem; color: var(--text-muted); }
        
        /* Next player notice */
        .next-player-notice { display: none; position: fixed; top: 0; left: 0; right: 0; background: linear-gradient(135deg, var(--success), #059669); padding: 15px 20px; z-index: 500; }
        .next-player-notice.active { display: block; animation: slideDown 0.3s ease; }
        .next-player-notice-content { max-width: 500px; margin: 0 auto; text-align: center; color: white; }
        .next-player-notice-title { font-weight: 700; font-size: 1.1rem; }

        /* Leaderboard */

        /* Toast */
        .toast { position: fixed; bottom: 100px; left: 50%; transform: translateX(-50%) translateY(100px); background: linear-gradient(135deg, var(--warning), #FF8F00); color: #000; padding: 18px 32px; border-radius: 50px; font-weight: 800; box-shadow: 0 10px 40px rgba(0,0,0,0.4); opacity: 0; transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); z-index: 2000; text-align: center; max-width: 90%; font-size: 1.05rem; text-transform: uppercase; letter-spacing: 1px; }
        .toast.show { transform: translateX(-50%) translateY(0); opacity: 1; }

        /* Win Animation Overlay */
        .win-overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.9); z-index: 3000; display: flex; flex-direction: column; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: opacity 0.5s; }
        .win-overlay.active { opacity: 1; pointer-events: auto; }
        .win-trophy { font-size: 8rem; animation: trophyBounce 1s ease infinite; }
        @keyframes trophyBounce { 0%, 100% { transform: scale(1) rotate(-5deg); } 50% { transform: scale(1.1) rotate(5deg); } }
        .win-title { font-size: 3rem; font-weight: 900; background: linear-gradient(135deg, #FFD700, #FFA500, #FF6347); -webkit-background-clip: text; -webkit-text-fill-color: transparent; margin: 20px 0; text-align: center; animation: winPulse 0.5s ease infinite alternate; }
        @keyframes winPulse { from { transform: scale(1); } to { transform: scale(1.05); } }
        .win-subtitle { font-size: 1.3rem; color: var(--text-muted); margin-bottom: 30px; }
        .confetti { position: absolute; width: 10px; height: 10px; opacity: 0; }
        @keyframes confettiFall { 0% { transform: translateY(-100vh) rotate(0deg); opacity: 1; } 100% { transform: translateY(100vh) rotate(720deg); opacity: 0; } }
        
        /* Analytics Styles */
        .analytics-container { background: linear-gradient(135deg, var(--card-bg), #1a1a2e); border-radius: 16px; padding: 20px; margin: 15px 0; border: 2px solid rgba(255,255,255,0.1); }
        .analytics-title { font-size: 1.1rem; font-weight: 700; color: var(--warning); margin-bottom: 15px; display: flex; align-items: center; gap: 8px; }
        .analytics-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; }
        .analytics-stat { background: rgba(0,0,0,0.3); border-radius: 12px; padding: 12px; text-align: center; }
        .analytics-value { font-size: 1.5rem; font-weight: 800; color: var(--primary); }
        .analytics-label { font-size: 0.75rem; color: var(--text-muted); text-transform: uppercase; letter-spacing: 1px; }
        .analytics-bar { height: 8px; background: rgba(255,255,255,0.1); border-radius: 4px; overflow: hidden; margin-top: 8px; }
        .analytics-bar-fill { height: 100%; border-radius: 4px; transition: width 0.5s ease; }
        
        /* Player row with wins and probability */
        .player-stats-row { display: flex; justify-content: space-between; align-items: center; padding: 12px 15px; background: rgba(0,0,0,0.2); border-radius: 12px; margin-bottom: 8px; }
        .player-stats-row.winner { background: linear-gradient(135deg, rgba(255,215,0,0.3), rgba(255,165,0,0.2)); border: 2px solid var(--warning); }
        .player-stats-name { font-weight: 700; display: flex; align-items: center; gap: 8px; }
        .player-stats-wins { font-size: 0.75rem; background: var(--success); color: white; padding: 2px 8px; border-radius: 10px; }
        .player-stats-score { font-weight: 800; }
        .player-stats-prob { font-size: 0.8rem; color: var(--text-muted); }
        .prob-high { color: var(--success); }
        .prob-med { color: var(--warning); }
        .prob-low { color: var(--danger); }

        /* ========== TABLET STYLES (iPad, etc) ========== */
        @media (min-width: 768px) and (max-width: 1024px) {
            .screen { padding: 15px; }
            #game-screen { padding: 10px; }
            .game-header { padding: 12px 20px; }
            .contract-num { font-size: 1.1rem; }
            .contract-desc { font-size: 0.95rem; }
            .turn-indicator { font-size: 1rem; padding: 12px 25px; margin: 8px 0; }
            .opponents-row { gap: 15px; padding: 10px; }
            .opponent-card { padding: 12px 18px; min-width: 110px; }
            .opponent-name { font-size: 0.95rem; }
            .table-area { gap: 50px; padding: 20px; margin-bottom: 8px; }
            .pile-cards { width: 80px; height: 112px; }
            .card { width: 80px; height: 112px; border-radius: 14px; }
            .card-rank { font-size: 1.6rem; }
            .card-suit { font-size: 1.8rem; }
            .melds-area { padding: 15px; margin-bottom: 8px; min-height: 50px; }
            .melds-title { font-size: 0.85rem; margin-bottom: 8px; }
            .meld-cards .card { width: 55px; height: 78px; }
            .hand-area { padding: 15px; }
            .hand-cards { gap: 10px; min-height: 130px; }
            .action-bar { gap: 15px; margin-top: 15px; }
            .action-btn { padding: 16px; font-size: 1rem; }
            .modal { max-width: 500px; padding: 30px; }
        }

        /* ========== TABLET LANDSCAPE ========== */
        @media (min-width: 768px) and (max-width: 1024px) and (orientation: landscape) {
            .screen { padding: 10px; min-height: auto; }
            #game-screen { padding: 8px 15px; }
            .game-header { padding: 8px 15px; }
            .turn-indicator { padding: 8px 20px; margin: 5px 0; font-size: 0.9rem; }
            .opponents-row { padding: 8px; gap: 12px; }
            .opponent-card { padding: 8px 12px; min-width: 90px; }
            .table-area { padding: 12px; gap: 40px; margin-bottom: 5px; }
            .pile-cards { width: 65px; height: 92px; }
            .card { width: 65px; height: 92px; }
            .card-rank { font-size: 1.3rem; }
            .card-suit { font-size: 1.5rem; }
            .melds-area { padding: 10px; margin-bottom: 5px; min-height: 40px; }
            .meld-cards .card { width: 45px; height: 64px; }
            .hand-area { padding: 10px; }
            .hand-cards { gap: 8px; min-height: 100px; }
            .action-bar { margin-top: 10px; gap: 12px; }
            .action-btn { padding: 12px; font-size: 0.9rem; }
        }

        /* ========== LARGE PHONE STYLES (iPhone Plus, Pro Max, etc) ========== */
        @media (min-width: 414px) and (max-width: 767px) {
            .screen { padding: 15px; }
            .logo h1 { font-size: 2.8rem; }
            .logo p { font-size: 1rem; }
            .game-header { padding: 12px 15px; flex-wrap: wrap; gap: 10px; }
            .contract-num { font-size: 1.1rem; }
            .turn-indicator { font-size: 0.95rem; padding: 12px 20px; margin: 10px 0; }
            .opponents-row { gap: 10px; padding: 10px; flex-wrap: nowrap; overflow-x: auto; -webkit-overflow-scrolling: touch; }
            .opponent-card { padding: 12px 15px; min-width: 100px; flex-shrink: 0; }
            .table-area { gap: 40px; padding: 20px; }
            .pile-cards { width: 75px; height: 105px; }
            .card { width: 75px; height: 105px; }
            .card-rank { font-size: 1.5rem; }
            .card-suit { font-size: 1.7rem; }
            .melds-area { padding: 15px; }
            .melds-container { gap: 12px; }
            .meld-cards .card { width: 48px; height: 68px; margin-left: -12px; }
            .hand-area { padding: 15px; }
            .hand-header { flex-wrap: wrap; gap: 8px; }
            .hand-cards { gap: 8px; min-height: 120px; }
            .action-bar { gap: 10px; }
            .action-btn { padding: 14px; font-size: 0.9rem; letter-spacing: 0; }
            .sort-btn { padding: 8px 12px; font-size: 0.8rem; }
            .modal { padding: 25px; max-width: 95%; }
            .buy-banner-content { padding: 20px; }
            .buy-banner-card { width: 60px; height: 85px; }
        }

        /* ========== SMALL PHONE STYLES (iPhone SE, older phones) ========== */
        @media (max-width: 413px) {
            .screen { padding: 10px; }
            .logo { margin-bottom: 40px; }
            .logo h1 { font-size: 2.2rem; }
            .logo p { font-size: 0.85rem; letter-spacing: 2px; }
            .menu-buttons { gap: 12px; }
            .btn { padding: 14px 20px; font-size: 0.95rem; }
            .game-header { padding: 10px 12px; }
            .contract-num { font-size: 1rem; }
            .contract-desc { font-size: 0.85rem; }
            .game-stats { font-size: 0.85rem; gap: 10px; }
            .turn-indicator { font-size: 0.85rem; padding: 10px 15px; margin: 8px 0; border-radius: 20px; }
            .opponents-row { gap: 8px; padding: 8px; overflow-x: auto; flex-wrap: nowrap; -webkit-overflow-scrolling: touch; }
            .opponent-card { padding: 10px 12px; min-width: 85px; flex-shrink: 0; }
            .opponent-name { font-size: 0.8rem; }
            .opponent-cards { font-size: 0.75rem; }
            .table-area { gap: 25px; padding: 15px; margin-bottom: 5px; }
            .pile-label { font-size: 0.75rem; margin-bottom: 6px; }
            .pile-cards { width: 65px; height: 95px; }
            .card { width: 65px; height: 95px; border-radius: 12px; border-width: 3px; }
            .card-rank { font-size: 1.3rem; }
            .card-suit { font-size: 1.5rem; }
            .deck-count { font-size: 0.7rem; padding: 3px 8px; }
            .melds-area { padding: 12px; margin-bottom: 8px; }
            .melds-title { font-size: 0.8rem; margin-bottom: 8px; }
            .meld-group { padding: 8px; }
            .meld-label { font-size: 0.65rem; margin-bottom: 5px; }
            .meld-cards .card { width: 40px; height: 58px; margin-left: -10px; border-width: 2px; }
            .meld-cards .card-rank { font-size: 0.9rem; }
            .meld-cards .card-suit { font-size: 1rem; }
            .hand-area { padding: 12px; }
            .hand-header { gap: 6px; margin-bottom: 8px; }
            .hand-title { font-size: 0.95rem; }
            .hand-controls { gap: 5px; }
            .sort-btn { padding: 6px 10px; font-size: 0.75rem; }
            .hand-cards { gap: 6px; min-height: 110px; padding: 8px 0; }
            .action-bar { gap: 8px; margin-top: 12px; }
            .action-btn { padding: 12px 8px; font-size: 0.8rem; border-radius: 10px; letter-spacing: 0; }
            .modal { padding: 20px; border-radius: 20px; }
            .modal-title { font-size: 1.3rem; }
            .modal-body { font-size: 0.9rem; }
            .toast { bottom: 80px; padding: 12px 20px; font-size: 0.9rem; }
            .buy-banner-content { padding: 15px; }
            .buy-banner-card { width: 50px; height: 70px; font-size: 1rem; }
            .buy-banner-title { font-size: 1.1rem; }
            .buy-banner-subtitle { font-size: 0.8rem; }
            .buy-banner-btn { padding: 12px 20px; font-size: 0.9rem; }
            .back-btn { width: 40px; height: 40px; font-size: 1.2rem; top: 15px; left: 15px; }
            .setup-screen { padding-top: 50px; }
            .setup-title { font-size: 1.5rem; margin-bottom: 25px; }
            .form-label { font-size: 0.85rem; }
            .form-input { padding: 12px 15px; font-size: 1rem; }
            .option-btn { padding: 12px; font-size: 1rem; }
            .diff-btn { padding: 10px; font-size: 0.85rem; }
            .mode-card { padding: 18px; }
            .mode-icon { font-size: 2.2rem; }
            .mode-title { font-size: 1.2rem; }
            .mode-desc { font-size: 0.9rem; }
            .mode-contracts { font-size: 0.7rem; padding: 8px; }
            /* Dead card overlay smaller on small phones */
            .card-dead-overlay { font-size: 2rem; }
            .meld-cards .card-dead-overlay { font-size: 1.2rem; }
        }

        /* ========== LANDSCAPE PHONE ========== */
        @media (max-height: 500px) and (orientation: landscape) {
            .screen { padding: 10px; min-height: auto; }
            .game-header { padding: 8px 15px; }
            .turn-indicator { padding: 8px 15px; margin: 5px 0; }
            .opponents-row { padding: 5px; }
            .opponent-card { padding: 8px 12px; }
            .table-area { padding: 10px; gap: 30px; margin-bottom: 5px; }
            .pile-cards { width: 55px; height: 80px; }
            .card { width: 55px; height: 80px; }
            .card-rank { font-size: 1.1rem; }
            .card-suit { font-size: 1.3rem; }
            .melds-area { padding: 8px; margin-bottom: 5px; }
            .meld-cards .card { width: 35px; height: 50px; }
            .hand-area { padding: 10px; }
            .hand-cards { min-height: 90px; gap: 5px; }
            .action-bar { margin-top: 8px; }
            .action-btn { padding: 10px; }
            .toast { bottom: 60px; }
        }

        /* ========== SAFE AREA FOR NOTCHED PHONES ========== */
        @supports (padding: env(safe-area-inset-bottom)) {
            .hand-area { padding-bottom: calc(12px + env(safe-area-inset-bottom)); }
            .action-bar { padding-bottom: env(safe-area-inset-bottom); }
            .toast { bottom: calc(100px + env(safe-area-inset-bottom)); }
            .modal { margin-bottom: env(safe-area-inset-bottom); }
        }

        /* ========== TOUCH IMPROVEMENTS ========== */
        @media (pointer: coarse) {
            .card { min-width: 50px; min-height: 70px; }
            .btn, .action-btn, .sort-btn, .option-btn, .diff-btn { min-height: 44px; }
            .back-btn { min-width: 44px; min-height: 44px; }
        }
    </style>
</head>
<body>
    <!-- WIN CELEBRATION OVERLAY -->
    <div class="win-overlay" id="win-overlay">
        <div class="win-trophy">üèÜ</div>
        <div class="win-title" id="win-title">YOU WIN!</div>
        <div class="win-subtitle" id="win-subtitle">Champion of Liverpool Rummy</div>
        <div id="win-confetti"></div>
    </div>

    <!-- Tutorial Tip -->
    <div class="tutorial-tip" id="tutorial-tip">
        <div class="tutorial-text" id="tutorial-text"></div>
        <div class="tutorial-controls">
            <button class="tutorial-btn" onclick="exitTutorial()">Exit</button>
        </div>
    </div>

    <!-- BUY BANNER - When it's YOUR turn to buy -->
    <div class="buy-banner" id="buy-banner">
        <div class="buy-banner-content">
            <div class="buy-banner-top">
                <div class="buy-banner-card" id="buy-banner-card"></div>
                <div class="buy-banner-text">
                    <div class="buy-banner-title">Buy this card?</div>
                    <div class="buy-banner-subtitle">You'll also draw 1 penalty card</div>
                </div>
            </div>
            <div class="buy-banner-buttons">
                <button class="buy-banner-btn buy-btn-yes" onclick="doBuy()">‚úì Buy It</button>
                <button class="buy-banner-btn buy-btn-no" onclick="doPass()">‚úó Pass</button>
            </div>
        </div>
    </div>
    
    <!-- BUY WAITING - When someone else is deciding -->
    <div class="buy-waiting" id="buy-waiting">
        <div class="buy-waiting-content">
            <div class="buy-waiting-title" id="buy-waiting-title">‚è≥ Waiting for Ruby to decide...</div>
            <div class="buy-waiting-detail" id="buy-waiting-detail">They can buy the discarded card before your turn</div>
        </div>
    </div>
    
    <!-- NEXT PLAYER NOTICE - When you're next and can just take it -->
    <div class="next-player-notice" id="next-player-notice">
        <div class="next-player-notice-content">
            <div class="next-player-notice-title">üéØ You're next! You can take the discard on your turn</div>
        </div>
    </div>

    <!-- TITLE -->
    <div id="title-screen" class="screen active">
        <div class="logo">
            <h1>Liverpool Rummy</h1>
            <p>Contract Rummy Card Game</p>
        </div>
        <div class="menu-buttons">
            <button class="btn btn-primary" onclick="showScreen('mode-select')">üéÆ Play Game</button>
            <button class="btn btn-secondary" onclick="rejoinRoom()">‚Ü© Rejoin Online Game</button>
            <button class="btn btn-secondary" onclick="showRules()">üìñ How to Play</button>
            <button class="btn btn-secondary" onclick="showCustomizeCards()">üé® Custom Cards</button>
        </div>
    </div>

    <!-- GAME MODE SELECT -->
    <div id="mode-select" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('title-screen')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Select Game Mode</h2>
            <div class="mode-cards">
                <div class="mode-card" onclick="selectMode('classic')">
                    <div class="mode-icon">üÉè</div>
                    <div class="mode-title">Classic</div>
                    <div class="mode-desc">7 Contracts - Full Game</div>
                    <div class="mode-contracts">2 Sets ‚Üí 1+1 ‚Üí 2 Runs ‚Üí 3 Sets ‚Üí 2+1 ‚Üí 1+2 ‚Üí 3 Runs</div>
                </div>
                <div class="mode-card" onclick="selectMode('quick')">
                    <div class="mode-icon">‚ö°</div>
                    <div class="mode-title">Quick Rummy</div>
                    <div class="mode-desc">4 Contracts - Fast Game</div>
                    <div class="mode-contracts">2 Sets ‚Üí 2 Runs ‚Üí 3 Sets ‚Üí 3 Runs</div>
                </div>
            </div>
        </div>
    </div>

    <!-- PLAY TYPE SELECT -->
    <div id="play-type" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('mode-select')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title" id="play-type-title">Classic Mode</h2>
            <div class="menu-buttons">
                <button class="btn btn-primary" onclick="showScreen('online-menu')">üåê Play Online</button>
                <button class="btn btn-secondary" onclick="showScreen('solo-setup')">ü§ñ Play vs CPU</button>
                <button class="btn btn-success" onclick="startTutorial()">üéØ Tutorial</button>
                <button class="btn btn-success" onclick="quickStartSolo()">‚ñ∂ Quick Play (CPU)</button>
            </div>
        </div>
    </div>

    <!-- ONLINE MENU -->
    <div id="online-menu" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('play-type')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Play Online</h2>
            <div class="menu-buttons">
                <button class="btn btn-primary" onclick="showScreen('create-room')">Create Game</button>
                <button class="btn btn-secondary" onclick="showScreen('join-room')">Join Game</button>
            </div>
        </div>
    </div>

    <!-- CREATE ROOM -->
    <div id="create-room" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('online-menu')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Create Game</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="host-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Number of Players</label>
                <div class="option-grid" id="player-count-grid">
                    <button class="option-btn" data-val="2">2</button>
                    <button class="option-btn selected" data-val="3">3</button>
                    <button class="option-btn" data-val="4">4</button>
                    <button class="option-btn" data-val="5">5</button>
                    <button class="option-btn" data-val="6">6</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">CPU Difficulty (if adding CPUs)</label>
                <div class="diff-grid" id="online-diff-grid">
                    <button class="diff-btn easy selected" data-val="easy">Easy</button>
                    <button class="diff-btn medium" data-val="medium">Medium</button>
                    <button class="diff-btn hard" data-val="hard">Hard</button>
                </div>
            </div>
            <button class="btn btn-success" onclick="createRoom()">Create Room</button>
        </div>
    </div>

    <!-- JOIN ROOM -->
    <div id="join-room" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('online-menu')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Join Game</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="join-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Room Code</label>
                <input type="text" id="room-code-input" class="form-input" placeholder="ABCD" maxlength="4" style="text-transform:uppercase;text-align:center;font-size:1.5rem;letter-spacing:0.3em;">
            </div>
            <button class="btn btn-success" onclick="joinRoom()">Join Room</button>
        </div>
    </div>

    <!-- LOBBY HOST -->
    <div id="lobby-host" class="screen setup-screen">
        <button class="back-btn" onclick="leaveRoom()">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Game Lobby</h2>
            <div class="room-code-box">
                <div class="room-code-label">Share this code with friends</div>
                <div class="room-code" id="display-code">----</div>
            </div>
            <div class="players-list">
                <div class="players-list-title">Players (<span id="p-count">0</span>/<span id="max-p">3</span>)</div>
                <div id="players-box"></div>
            </div>
            <button class="btn btn-secondary" id="add-cpu-btn" onclick="addCPU()" style="margin-bottom:15px;">ü§ñ Add CPU Player</button>
            <button class="btn btn-success" id="start-btn" onclick="startOnlineGame()" disabled>Waiting for players...</button>
        </div>
    </div>

    <!-- LOBBY GUEST -->
    <div id="lobby-guest" class="screen setup-screen">
        <button class="back-btn" onclick="leaveRoom()">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Waiting for Host</h2>
            <div class="room-code-box">
                <div class="room-code-label">Room Code</div>
                <div class="room-code" id="display-code-guest">----</div>
            </div>
            <div class="players-list">
                <div class="players-list-title">Players</div>
                <div id="players-box-guest"></div>
            </div>
            <p style="text-align:center;color:var(--text-muted);">Waiting for host to start...</p>
        </div>
    </div>

    <!-- SOLO SETUP -->
    <div id="solo-setup" class="screen setup-screen">
        <button class="back-btn" onclick="showScreen('play-type')">‚Üê</button>
        <div class="container">
            <h2 class="setup-title">Play vs CPU</h2>
            <div class="form-group">
                <label class="form-label">Your Name</label>
                <input type="text" id="solo-name" class="form-input" placeholder="Enter your name" maxlength="12">
            </div>
            <div class="form-group">
                <label class="form-label">Number of Players</label>
                <div class="option-grid" id="solo-player-grid">
                    <button class="option-btn" data-val="2">2</button>
                    <button class="option-btn selected" data-val="3">3</button>
                    <button class="option-btn" data-val="4">4</button>
                    <button class="option-btn" data-val="5">5</button>
                    <button class="option-btn" data-val="6">6</button>
                </div>
            </div>
            <div class="form-group">
                <label class="form-label">CPU Difficulty</label>
                <div class="diff-grid" id="diff-grid">
                    <button class="diff-btn easy selected" data-val="easy">Easy</button>
                    <button class="diff-btn medium" data-val="medium">Medium</button>
                    <button class="diff-btn hard" data-val="hard">Hard</button>
                </div>
            </div>
            <button class="btn btn-success" onclick="startSoloGame()">Start Game</button>
        </div>
    </div>

    <!-- GAME -->
    <div id="game-screen" class="screen">
        <div class="game-header">
            <div class="contract-info">
                <div class="contract-num">Contract <span id="c-num">1</span> of <span id="c-total">7</span></div>
                <div class="contract-desc" id="c-desc">2 Sets</div>
            </div>
            <div class="header-actions">
                <div class="game-stats">
                    <div>Deck: <span id="deck-num">0</span></div>
                    <div>Score: <span id="my-score">0</span></div>
                </div>
                <button class="sound-btn" id="sound-toggle" onclick="toggleSound()" title="Toggle sound effects">üîä</button>
            </div>
        </div>
        <div class="turn-indicator" id="turn-ind">Waiting...</div>
        <div class="cpu-status" id="cpu-status"></div>
        <div class="opponents-row" id="opp-row"></div>
        <div class="table-area">
            <div class="pile deck-pile">
                <div class="pile-label">DRAW</div>
                <div class="pile-cards" onclick="drawDeck()">
                    <div class="card card-back"></div>
                    <span class="deck-count" id="deck-lbl">52</span>
                </div>
            </div>
            <div class="pile">
                <div class="pile-label">DISCARD</div>
                <div class="pile-cards" onclick="drawDiscard()">
                    <div class="card card-front" id="discard-top"></div>
                </div>
            </div>
        </div>
        <div class="melds-area">
            <div class="melds-title">Sets & Runs on Table</div>
            <div class="melds-container" id="melds-box"><span style="color:var(--text-muted);font-size:0.9rem;">None yet</span></div>
        </div>
        <div class="hand-area">
            <div class="hand-header">
                <span class="hand-title">Your Hand (<span id="hand-num">0</span>) <span id="my-wins-badge" style="font-size:0.7rem;background:var(--success);padding:2px 6px;border-radius:8px;margin-left:4px;display:none;"></span> <span id="my-prob" style="font-size:0.8rem;margin-left:8px;"></span></span>
                <div class="hand-controls">
                    <span class="selection-badge" id="sel-badge">0 selected</span>
                    <button class="sort-btn" onclick="toggleSortMode()" id="sort-mode-btn">Sort: Suit</button>
                    <button class="sort-btn" onclick="toggleWildPos()" id="wild-pos-btn">Wild: Auto</button>
                    <button class="sort-btn" onclick="sortHand()">Apply Sort</button>
                    <button class="sort-btn" onclick="clearSelection()">Clear Sel</button>
                    <button class="sort-btn" id="btn-move-left" onclick="moveCardLeft()" title="Move Left">‚óÄ</button>
                    <button class="sort-btn" id="btn-move-right" onclick="moveCardRight()" title="Move Right">‚ñ∂</button>
                </div>
            </div>
            <div class="hand-cards" id="hand-box"></div>
            <div class="action-bar">
                <button class="action-btn btn-laydown" id="btn-lay" onclick="layDown()" disabled>Lay Down</button>
                <button class="action-btn btn-addto" id="btn-add" onclick="showAddModal()" disabled>Add To</button>
                <button class="action-btn btn-discard" id="btn-disc" onclick="doDiscard()" disabled>Discard</button>
                <button class="action-btn btn-secondary" onclick="restartContract()">Restart</button>
            </div>
        </div>
    </div>

    <!-- MODAL -->
    <div class="modal-overlay" id="modal-overlay">
        <div class="modal">
            <h3 class="modal-title" id="modal-title">Modal</h3>
            <div class="modal-body" id="modal-body"></div>
            <div class="modal-buttons" id="modal-btns"></div>
        </div>
    </div>

    <!-- TOAST -->
    <div class="toast" id="toast"></div>
    
    <!-- Guide -->
    <div class="clippy hidden" id="clippy">
        <div class="clippy-avatar">üí¨</div>
        <div class="clippy-text" id="clippy-text">Tip text</div>
        <div class="clippy-actions">
            <button class="clippy-btn" onclick="nextClippy()">Next</button>
            <button class="clippy-btn" onclick="hideClippy()">√ó</button>
        </div>
    </div>

    <script>
        // Firebase
        firebase.initializeApp({
            apiKey: "AIzaSyA_oxxemFHZUCkZ8rHZncw4ffILWNwKAw4",
            authDomain: "liverpool-9b034.firebaseapp.com",
            databaseURL: "https://liverpool-9b034-default-rtdb.firebaseio.com",
            projectId: "liverpool-9b034"
        });
        const db = firebase.database();

        // Custom Card Images - stored in localStorage for persistence
        function loadCustomImages() {
            const joker = localStorage.getItem('customJoker');
            const queen = localStorage.getItem('customQueen');
            if (joker) CUSTOM_CARDS.jokerData = joker;
            if (queen) CUSTOM_CARDS.queenData = queen;
        }
        
        function setCustomImage(type, dataUrl) {
            if (type === 'joker') {
                CUSTOM_CARDS.jokerData = dataUrl;
                localStorage.setItem('customJoker', dataUrl);
            } else if (type === 'queen') {
                CUSTOM_CARDS.queenData = dataUrl;
                localStorage.setItem('customQueen', dataUrl);
            }
            if (G.started) render();
            toast('Custom ' + type + ' image set!');
        }
        
        function handleImageUpload(input, type) {
            const file = input.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => setCustomImage(type, e.target.result);
            reader.readAsDataURL(file);
        }
        
        function showCustomizeCards() {
            modal('Customize Cards', `
                <div style="text-align:center;">
                    <p style="margin-bottom:20px;color:var(--text-muted);">Upload photos to use as card faces!</p>
                    
                    <div style="margin-bottom:25px;">
                        <div style="font-weight:700;margin-bottom:10px;">üÉè Joker Card</div>
                        <label class="btn btn-secondary btn-sm" style="cursor:pointer;">
                            Choose Photo
                            <input type="file" accept="image/*" style="display:none;" onchange="handleImageUpload(this, 'joker')">
                        </label>
                        ${CUSTOM_CARDS.jokerData ? '<div style="color:var(--success);margin-top:8px;">‚úì Custom image set</div>' : ''}
                    </div>
                    
                    <div style="margin-bottom:25px;">
                        <div style="font-weight:700;margin-bottom:10px;">üëë Queen Cards</div>
                        <label class="btn btn-secondary btn-sm" style="cursor:pointer;">
                            Choose Photo
                            <input type="file" accept="image/*" style="display:none;" onchange="handleImageUpload(this, 'queen')">
                        </label>
                        ${CUSTOM_CARDS.queenData ? '<div style="color:var(--success);margin-top:8px;">‚úì Custom image set</div>' : ''}
                    </div>
                    
                    <div style="margin-top:20px;padding-top:15px;border-top:1px solid var(--card-hover);">
                        <button class="btn btn-danger btn-sm" onclick="clearCustomImages()" style="width:auto;padding:10px 20px;">
                            Clear All Custom Images
                        </button>
                    </div>
                </div>
            `, [{text:'Done', cls:'btn-primary'}]);
        }
        
        function clearCustomImages() {
            localStorage.removeItem('customJoker');
            localStorage.removeItem('customQueen');
            delete CUSTOM_CARDS.jokerData;
            delete CUSTOM_CARDS.queenData;
            toast('Custom images cleared');
            closeModal();
        }
        
        // Load custom images on startup
        loadCustomImages();

        // Constants
        const SUITS = ['hearts','diamonds','clubs','spades'];
        const RANKS = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
        const RANK_VAL = {A:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,10:10,J:11,Q:12,K:13};
        const POINTS = {A:15,2:20,3:5,4:5,5:5,6:5,7:5,8:5,9:5,10:10,J:10,Q:10,K:10,JOKER:20};
        const SUIT_SYM = {hearts:'‚ô•',diamonds:'‚ô¶',clubs:'‚ô£',spades:'‚ô†'};
        const IS_TOUCH = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
        let CARD_ID = 0;
        
        function runVal(rank, aceHigh = false) {
            if (rank === 'A') return aceHigh ? 14 : 1;
            return RANK_VAL[rank] || 0;
        }
        function makeCard(suit, rank) {
            return {suit, rank, wild: rank === '2' || rank === 'JOKER', id: 'c' + (CARD_ID++)};
        }
        function sortVal(rank) {
            return rank === 'A' ? 14 : (RANK_VAL[rank] || 0);
        }
        function adjustRunOrder(run) {
            if (wildPos === 'auto') return run;
            const naturals = run.filter(c => !c.wild).sort((a,b) => runVal(a.rank,true) - runVal(b.rank,true));
            const wilds = run.filter(c => c.wild);
            return wildPos === 'front' ? [...wilds, ...naturals] : [...naturals, ...wilds];
        }
        function selectButton(gridSel, val) {
            const grid = document.querySelector(gridSel);
            if (!grid) return;
            grid.querySelectorAll('.option-btn, .diff-btn').forEach(b => b.classList.remove('selected'));
            const btn = grid.querySelector(`[data-val="${val}"]`);
            if (btn) btn.classList.add('selected');
        }
        function loadSettings() {
            const mode = localStorage.getItem('lastMode');
            if (mode === 'quick') {
                gameMode = 'quick';
                CONTRACTS = QUICK_CONTRACTS;
                document.getElementById('play-type-title').textContent = '‚ö° Quick Rummy';
            } else if (mode === 'classic') {
                gameMode = 'classic';
                CONTRACTS = CLASSIC_CONTRACTS;
                document.getElementById('play-type-title').textContent = 'üÉè Classic Mode';
            }
            const soloName = localStorage.getItem('soloName'); if (soloName) document.getElementById('solo-name').value = soloName;
            const soloPlayers = localStorage.getItem('soloPlayers'); if (soloPlayers) selectButton('#solo-player-grid', soloPlayers);
            const soloDiff = localStorage.getItem('soloDiff'); if (soloDiff) selectButton('#diff-grid', soloDiff);
            const onlineName = localStorage.getItem('onlineName'); if (onlineName) document.getElementById('host-name').value = onlineName;
            const onlineMax = localStorage.getItem('onlineMax'); if (onlineMax) selectButton('#player-count-grid', onlineMax);
            const onlineDiff = localStorage.getItem('onlineDiff'); if (onlineDiff) selectButton('#online-diff-grid', onlineDiff);
        }
        function registerServiceWorker() {
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js').catch(err => console.log('SW register failed', err));
            }
        }

        // Clippy/Guide
        let clippyIdx = 0;
        let clippyTimer = null;
        function initClippy() {
            const enabled = localStorage.getItem('clippyEnabled') === 'true';
            if (!enabled) return hideClippy(true);
            showClippy();
        }
        function showClippy() {
            const el = document.getElementById('clippy');
            const txt = document.getElementById('clippy-text');
            if (!el || !txt) return;
            clippyIdx = Math.floor(Math.random() * CLIPPY_TIPS.length);
            txt.textContent = CLIPPY_TIPS[clippyIdx];
            el.classList.remove('hidden');
            scheduleClippy();
        }
        function hideClippy(silent=false) {
            const el = document.getElementById('clippy');
            if (el) el.classList.add('hidden');
            if (!silent) localStorage.setItem('clippyEnabled', 'false');
            clearTimeout(clippyTimer);
        }
        function nextClippy() {
            const txt = document.getElementById('clippy-text');
            if (!txt) return;
            clippyIdx = (clippyIdx + 1) % CLIPPY_TIPS.length;
            txt.textContent = CLIPPY_TIPS[clippyIdx];
            scheduleClippy();
        }
        function scheduleClippy() {
            clearTimeout(clippyTimer);
            clippyTimer = setTimeout(nextClippy, 15000);
        }
        function toggleClippySetting(on) {
            localStorage.setItem('clippyEnabled', on ? 'true' : 'false');
            if (on) showClippy(); else hideClippy();
        }
        
        // Game mode contracts
        const CLASSIC_CONTRACTS = [
            {id:1,sets:2,runs:0,cards:7,desc:'2 Sets'},
            {id:2,sets:1,runs:1,cards:8,desc:'1 Set + 1 Run'},
            {id:3,sets:0,runs:2,cards:9,desc:'2 Runs'},
            {id:4,sets:3,runs:0,cards:10,desc:'3 Sets'},
            {id:5,sets:2,runs:1,cards:11,desc:'2 Sets + 1 Run'},
            {id:6,sets:1,runs:2,cards:12,desc:'1 Set + 2 Runs'},
            {id:7,sets:0,runs:3,cards:13,desc:'3 Runs (all cards)'}
        ];
        const QUICK_CONTRACTS = [
            {id:1,sets:2,runs:0,cards:7,desc:'2 Sets'},
            {id:2,sets:0,runs:2,cards:9,desc:'2 Runs'},
            {id:3,sets:3,runs:0,cards:10,desc:'3 Sets'},
            {id:4,sets:0,runs:3,cards:13,desc:'3 Runs (all cards)'}
        ];
        
        let CONTRACTS = CLASSIC_CONTRACTS; // Default to classic
        let gameMode = 'classic';
        
        const CPU_NAMES = ['Ruby','Emerald','Sapphire','Topaz','Amethyst','Opal'];
        let wildPos = 'auto'; // auto | front | end
        const CLIPPY_TIPS = [
            'Need a discard? Tap the pile, but only if the top card isn‚Äôt dead (üíÄ).',
            'You can reorder with ‚óÄ ‚ñ∂ or Auto Sort. Wilds are always last.',
            'Runs need 3 naturals; sets need 1 natural. Wilds fill the gaps.',
            'Dead cards can‚Äôt be bought. Look for the üíÄ overlay on the discard.',
            'Use ‚ÄúRestart‚Äù in offline games if something feels off.',
            'Ace can be high in a run (‚Ä¶Q-K-A).',
            'Touch ‚ÄúClear Sel‚Äù if you grabbed the wrong cards.'
        ];

        // State
        let G = {players:[],deck:[],discard:[],melds:[],cur:0,contract:0,phase:'draw',drawn:false,buyQ:[],buyer:-1,started:false,hostId:null,deadCards:[]};
        let L = {myId:null,myName:'Player',isHost:false,isOnline:false,code:null,roomRef:null,gameRef:null,sel:[],maxP:3,diff:'easy',tutorial:false};
        const TUTORIAL_BASIC = [
            {id:'draw', text:'Tap the DRAW pile to draw a card.', trigger:'after-draw'},
            {id:'select', text:'Select all the 3s and 5s (two sets) in your hand.', trigger:'selected-basic'},
            {id:'lay', text:'Tap LAY DOWN to place your sets on the table.', trigger:'laid'},
            {id:'discard', text:'Select your last card and discard to end your turn.', trigger:'discarded'},
            {id:'done', text:'Nice! Tutorial complete. Start a real game from the menu.', trigger:null}
        ];
        const TUTORIAL_ADV = [
            {id:'draw', text:'Tap the DISCARD pile to take the top card.', trigger:'after-draw'},
            {id:'select-run', text:'Select the hearts run 10-J-Q-K-A (A is high).', trigger:'selected-adv'},
            {id:'lay', text:'Tap LAY DOWN to place your run.', trigger:'laid'},
            {id:'discard', text:'Discard your last card to finish.', trigger:'discarded'},
            {id:'done', text:'Great! You bought a discard and made a K-A run.', trigger:null}
        ];
        let tutorialStep = null;
        let tutorialSteps = TUTORIAL_BASIC;
        let tutorialLevel = 'basic';
        
        // Analytics tracking
        let analytics = {
            roundsPlayed: 0,
            roundWins: {},      // {playerName: count}
            cardsBought: {},    // {playerName: count}
            cardsPlayed: {},    // {playerName: count}
            wildsUsed: {},      // {playerName: count}
            turnsPlayed: {},    // {playerName: count}
            playerWins: {}      // Cached leaderboard wins
        };
        
        function resetAnalytics() {
            analytics = {
                roundsPlayed: 0,
                roundWins: {},
                cardsBought: {},
                cardsPlayed: {},
                wildsUsed: {},
                turnsPlayed: {},
                playerWins: {}
            };
        }
        
        function trackStat(stat, playerName, amount = 1) {
            if (!analytics[stat][playerName]) analytics[stat][playerName] = 0;
            analytics[stat][playerName] += amount;
        }
        
        // Calculate win probability based on current game state
        function calculateWinProbability(player, allPlayers) {
            const totalContracts = CONTRACTS.length;
            const currentContract = G.contract;
            const remainingContracts = totalContracts - currentContract;
            
            // Factors that influence win probability:
            // 1. Current score (lower is better) - 40% weight
            // 2. Hand size (fewer cards = closer to laying down) - 20% weight  
            // 3. Round wins so far - 15% weight
            // 4. Cards played efficiency - 10% weight
            // 5. Has laid down this round - 15% weight
            
            const scores = allPlayers.map(p => p.score);
            const minScore = Math.min(...scores);
            const maxScore = Math.max(...scores);
            const scoreRange = maxScore - minScore || 1;
            
            // Score factor (0-1, higher is better for lower scores)
            const scoreFactor = 1 - ((player.score - minScore) / scoreRange);
            
            // Hand size factor (0-1, fewer cards = higher)
            const handSizes = allPlayers.map(p => p.hand?.length || 0);
            const maxHand = Math.max(...handSizes) || 1;
            const handFactor = 1 - ((player.hand?.length || 0) / maxHand);
            
            // Round wins factor
            const roundWins = analytics.roundWins[player.name] || 0;
            const maxRoundWins = Math.max(...Object.values(analytics.roundWins), 1);
            const roundWinFactor = roundWins / maxRoundWins;
            
            // Laid down factor
            const laidFactor = player.laid ? 1 : 0;
            
            // Historical wins factor (from leaderboard)
            const histWins = analytics.playerWins[player.name] || 0;
            const maxHistWins = Math.max(...Object.values(analytics.playerWins), 1);
            const histFactor = histWins / maxHistWins;
            
            // Weighted probability
            let prob = (
                scoreFactor * 0.35 +
                handFactor * 0.20 +
                roundWinFactor * 0.15 +
                laidFactor * 0.15 +
                histFactor * 0.15
            );
            
            // Normalize to percentage
            prob = Math.round(prob * 100);
            
            // Ensure reasonable bounds
            return Math.max(5, Math.min(95, prob));
        }
        
        // Fetch player wins from leaderboard
        async function fetchPlayerWins(playerNames) {
            for (const name of playerNames) {
                try {
                    const safeName = name.trim().substring(0, 12).replace(/[.#$\/\[\]]/g, '_');
                    const snap = await db.ref('leaderboard/' + safeName).once('value');
                    const data = snap.val();
                    if (data && data.wins) {
                        analytics.playerWins[name] = data.wins;
                    }
                } catch (e) {
                    console.log('Could not fetch wins for', name);
                }
            }
        }
        
        // Game mode selection
        function selectMode(mode) {
            gameMode = mode;
            if (mode === 'quick') {
                CONTRACTS = QUICK_CONTRACTS;
                document.getElementById('play-type-title').textContent = '‚ö° Quick Rummy';
            } else {
                CONTRACTS = CLASSIC_CONTRACTS;
                document.getElementById('play-type-title').textContent = 'üÉè Classic Mode';
            }
            L.tutorial = false;
            localStorage.setItem('lastMode', mode);
            showScreen('play-type');
        }

        // Screens
        function showScreen(id) {
            document.querySelectorAll('.screen').forEach(s => s.classList.remove('active'));
            document.getElementById(id).classList.add('active');
            if (id === 'title-screen') {
                document.getElementById('clippy')?.classList.add('hidden');
            }
        }

        // Option buttons
        document.querySelectorAll('.option-grid, .diff-grid').forEach(grid => {
            grid.onclick = e => {
                const btn = e.target.closest('.option-btn, .diff-btn');
                if (!btn) return;
                grid.querySelectorAll('.option-btn, .diff-btn').forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
            };
        });

        // Toast
        function toast(msg) {
            const t = document.getElementById('toast');
            t.textContent = msg;
            t.classList.add('show');
            setTimeout(() => t.classList.remove('show'), 2500);
        }

        // Modal
        function modal(title, body, btns) {
            document.getElementById('modal-title').textContent = title;
            document.getElementById('modal-body').innerHTML = body;
            const bc = document.getElementById('modal-btns');
            bc.innerHTML = '';
            btns.forEach(b => {
                const btn = document.createElement('button');
                btn.className = 'btn ' + (b.cls || 'btn-secondary');
                btn.textContent = b.text;
                btn.onclick = () => { closeModal(); if (b.fn) b.fn(); };
                bc.appendChild(btn);
            });
            document.getElementById('modal-overlay').classList.add('active');
        }
        function closeModal() { document.getElementById('modal-overlay').classList.remove('active'); }

        // Deck
        let cardIdCounter = 0;
        function makeDeck(n) {
            const d = [];
            for (let i = 0; i < n; i++) {
                for (const s of SUITS) {
                    for (const r of RANKS) {
                        d.push({id: cardIdCounter++, suit:s, rank:r, wild: r==='2'});
                    }
                }
            }
            d.push({id: cardIdCounter++, suit:null,rank:'JOKER',wild:true});
            d.push({id: cardIdCounter++, suit:null,rank:'JOKER',wild:true});
            return shuffle(d);
        }
        function shuffle(a) {
            for (let i = a.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [a[i], a[j]] = [a[j], a[i]];
            }
            return a;
        }
        function numDecks(p) { return p <= 4 ? 2 : 2 + Math.floor((p - 4) / 2); }

        // Online
        function genCode() {
            const c = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            let r = '';
            for (let i = 0; i < 4; i++) r += c[Math.floor(Math.random() * c.length)];
            return r;
        }

        async function createRoom() {
            const name = document.getElementById('host-name').value.trim() || 'Host';
            const max = parseInt(document.querySelector('#player-count-grid .selected').dataset.val);
            const diffBtn = document.querySelector('#online-diff-grid .selected');
            L.diff = diffBtn ? diffBtn.dataset.val : 'easy';
            L.tutorial = false;
            localStorage.setItem('onlineName', name);
            localStorage.setItem('onlineMax', max);
            localStorage.setItem('onlineDiff', L.diff);
            L.myName = name; L.myId = 'p_' + Date.now(); L.isHost = true; L.isOnline = true; L.maxP = max; L.code = genCode();
            localStorage.setItem('lastRoomCode', L.code);
            localStorage.setItem('lastPlayerId', L.myId);
            localStorage.setItem('lastPlayerName', name);
            localStorage.setItem('lastIsHost', 'true');
            const data = {code: L.code, hostId: L.myId, maxP: max, difficulty: L.diff, players: {[L.myId]: {name, isHost:true, isCPU:false, conn:true}}, started:false};
            try {
                L.roomRef = db.ref('rooms/' + L.code);
                await L.roomRef.set(data);
                L.roomRef.child('players/' + L.myId + '/conn').onDisconnect().set(false);
                L.roomRef.on('value', onRoom);
                document.getElementById('display-code').textContent = L.code;
                document.getElementById('max-p').textContent = max;
                showScreen('lobby-host');
                toast('Room created!');
            } catch (e) { toast('Error: ' + e.message); }
        }

        async function joinRoom() {
            const name = document.getElementById('join-name').value.trim() || 'Player';
            const code = document.getElementById('room-code-input').value.toUpperCase().trim();
            if (code.length !== 4) return toast('Enter 4-letter code');
            L.tutorial = false;
            L.myName = name; L.myId = 'p_' + Date.now(); L.isHost = false; L.isOnline = true; L.code = code;
            localStorage.setItem('onlineName', name);
            localStorage.setItem('lastRoomCode', code);
            localStorage.setItem('lastPlayerId', L.myId);
            localStorage.setItem('lastPlayerName', name);
            localStorage.setItem('lastIsHost', 'false');
            try {
                L.roomRef = db.ref('rooms/' + code);
                const snap = await L.roomRef.once('value');
                const d = snap.val();
                if (!d) return toast('Room not found');
                if (d.started) return toast('Game already started');
                const cnt = Object.values(d.players || {}).filter(p => p.conn).length;
                if (cnt >= d.maxP) return toast('Room is full');
                await L.roomRef.child('players/' + L.myId).set({name, isHost:false, isCPU:false, conn:true});
                L.roomRef.child('players/' + L.myId + '/conn').onDisconnect().set(false);
                L.roomRef.on('value', onRoom);
                document.getElementById('display-code-guest').textContent = code;
                showScreen('lobby-guest');
                toast('Joined!');
            } catch (e) { toast('Error: ' + e.message); }
        }

        function onRoom(snap) {
            const d = snap.val();
            if (!d) { toast('Room closed'); showScreen('title-screen'); return; }
            const ps = Object.entries(d.players || {}).filter(([,p]) => p.conn !== false);
            if (L.isHost) updateHostLobby(ps, d.maxP);
            else updateGuestLobby(ps);
            if (d.started && d.game) {
                G = fixGameState(d.game);
                L.gameRef = L.roomRef.child('game');
                L.gameRef.on('value', onGame);
                showScreen('game-screen');
                render();
            }
        }

        function updateHostLobby(ps, max) {
            document.getElementById('p-count').textContent = ps.length;
            document.getElementById('max-p').textContent = max;
            document.getElementById('players-box').innerHTML = ps.map(([id, p]) => `
                <div class="player-row">
                    <span class="player-name">${p.isCPU ? 'ü§ñ ' : ''}${p.name}
                        ${id === L.myId ? '<span class="badge badge-you">You</span>' : ''}
                        ${p.isHost ? '<span class="badge badge-host">Host</span>' : ''}
                    </span>
                    ${p.isCPU ? `<button class="remove-btn" onclick="removeCPU('${id}')">√ó</button>` : ''}
                </div>
            `).join('');
            document.getElementById('add-cpu-btn').style.display = ps.length >= max ? 'none' : 'flex';
            const btn = document.getElementById('start-btn');
            btn.disabled = ps.length < 2;
            btn.textContent = ps.length < 2 ? 'Need 2+ players' : 'Start Game';
        }

        function updateGuestLobby(ps) {
            document.getElementById('players-box-guest').innerHTML = ps.map(([id, p]) => `
                <div class="player-row">
                    <span class="player-name">${p.isCPU ? 'ü§ñ ' : ''}${p.name}
                        ${id === L.myId ? '<span class="badge badge-you">You</span>' : ''}
                        ${p.isHost ? '<span class="badge badge-host">Host</span>' : ''}
                    </span>
                </div>
            `).join('');
        }

        async function addCPU() {
            const snap = await L.roomRef.once('value');
            const d = snap.val();
            const ps = Object.values(d.players || {}).filter(p => p.conn !== false);
            if (ps.length >= d.maxP) return toast('Room full');
            const used = ps.map(p => p.name);
            const name = CPU_NAMES.find(n => !used.includes(n)) || 'CPU';
            await L.roomRef.child('players/cpu_' + Date.now()).set({name, isHost:false, isCPU:true, conn:true});
            toast('Added ' + name);
        }

        async function removeCPU(id) { await L.roomRef.child('players/' + id).remove(); }

        async function leaveRoom() {
            if (L.roomRef) {
                if (L.isHost) await L.roomRef.remove();
                else await L.roomRef.child('players/' + L.myId).remove();
                L.roomRef.off();
                if (L.gameRef) L.gameRef.off();
            }
            L.isOnline = false;
            showScreen('title-screen');
        }

        async function rejoinRoom() {
            const code = localStorage.getItem('lastRoomCode');
            const pid = localStorage.getItem('lastPlayerId');
            const pname = localStorage.getItem('lastPlayerName');
            const wasHost = localStorage.getItem('lastIsHost') === 'true';
            if (!code || !pid || !pname) return toast('No game to rejoin');
            try {
                L.myName = pname; L.myId = pid; L.isHost = wasHost; L.isOnline = true; L.code = code;
                L.roomRef = db.ref('rooms/' + code);
                const snap = await L.roomRef.once('value');
                const d = snap.val();
                if (!d) return toast('Room not found');
                if (d.started && d.players && d.players[pid]) {
                    await L.roomRef.child('players/' + pid + '/conn').set(true);
                } else if (d.players && !d.players[pid]) {
                    await L.roomRef.child('players/' + pid).set({name:pname, isHost:false, isCPU:false, conn:true});
                }
                L.roomRef.child('players/' + pid + '/conn').onDisconnect().set(false);
                L.roomRef.on('value', onRoom);
                showScreen('lobby-guest');
                document.getElementById('display-code-guest').textContent = code;
                toast('Rejoined room ' + code);
            } catch (e) {
                toast('Could not rejoin: ' + e.message);
            }
        }

        async function startOnlineGame() {
            const snap = await L.roomRef.once('value');
            const d = snap.val();
            const ps = Object.entries(d.players || {}).filter(([,p]) => p.conn !== false);
            L.diff = d.difficulty || 'easy'; // Get difficulty from room data
            L.tutorial = false;
            initGame(ps.map(([id, p]) => ({id, name: p.name, human: !p.isCPU, cpu: p.isCPU})));
            G.hostId = L.myId;
            await L.roomRef.update({started: true, game: G});
            // Trigger CPU if first player is CPU
            setTimeout(() => {
                if (G.players[0]?.cpu) checkCPU();
            }, 500);
        }

        // Firebase converts arrays to objects - this fixes them
        function fixGameState(g) {
            if (!g) return g;
            
            // Helper to fix wild property on cards (2s and Jokers should be wild)
            const fixCardWild = (card) => {
                if (card && (card.rank === '2' || card.rank === 'JOKER')) {
                    card.wild = true;
                }
                return card;
            };
            const fixCardsArray = (cards) => {
                if (!cards) return [];
                if (!Array.isArray(cards)) cards = Object.values(cards);
                return cards.map(fixCardWild);
            };
            
            // Fix deck array
            if (g.deck && !Array.isArray(g.deck)) {
                g.deck = Object.values(g.deck);
            }
            g.deck = fixCardsArray(g.deck);
            // Fix discard array
            if (g.discard && !Array.isArray(g.discard)) {
                g.discard = Object.values(g.discard);
            }
            g.discard = fixCardsArray(g.discard);
            // Fix melds array
            if (g.melds && !Array.isArray(g.melds)) {
                g.melds = Object.values(g.melds);
            }
            g.melds = g.melds || [];
            // Fix each meld's cards array
            g.melds.forEach(m => {
                if (m.cards && !Array.isArray(m.cards)) {
                    m.cards = Object.values(m.cards);
                }
                m.cards = fixCardsArray(m.cards);
            });
            // Fix players array and their hands
            if (g.players && !Array.isArray(g.players)) {
                g.players = Object.values(g.players);
            }
            g.players = g.players || [];
            g.players.forEach(p => {
                if (p.hand && !Array.isArray(p.hand)) {
                    p.hand = Object.values(p.hand);
                }
                p.hand = fixCardsArray(p.hand);
            });
            // Fix buyQ array
            if (g.buyQ && !Array.isArray(g.buyQ)) {
                g.buyQ = Object.values(g.buyQ);
            }
            g.buyQ = g.buyQ || [];
            // Fix deadCards array
            if (g.deadCards && !Array.isArray(g.deadCards)) {
                g.deadCards = Object.values(g.deadCards);
            }
            g.deadCards = g.deadCards || [];
            return g;
        }

        function onGame(snap) {
            const d = snap.val();
            if (!d) return;
            G = fixGameState(d);
            L.sel = [];
            render();
            // Host drives CPU turns; reset stuck flags so CPUs don't freeze
            if (L.isHost) {
                if (G.phase !== 'buying') cpuBuyingRunning = false;
                cpuRunning = false;
                setTimeout(() => {
                    checkCPU();
                    checkCPUBuying();
                }, 100);
            }
        }

        function sync() {
            if (L.isOnline && L.roomRef) {
                L.roomRef.child('game').set(G);
            } else { 
                render(); 
                setTimeout(() => {
                    checkCPU(); 
                    checkCPUBuying(); 
                }, 100);
            }
        }

        // Solo
        function startSoloGame() {
            L.tutorial = false;
            const name = document.getElementById('solo-name').value.trim() || 'You';
            const num = parseInt(document.querySelector('#solo-player-grid .selected').dataset.val);
            L.diff = document.querySelector('#diff-grid .selected').dataset.val;
            localStorage.setItem('soloName', name);
            localStorage.setItem('soloPlayers', num);
            localStorage.setItem('soloDiff', L.diff);
            L.myName = name; L.myId = 'human'; L.isHost = true; L.isOnline = false;
            const ps = [{id:'human', name, human:true, cpu:false}];
            const used = [name];
            for (let i = 1; i < num; i++) {
                const n = CPU_NAMES.find(x => !used.includes(x)) || 'CPU' + i;
                used.push(n);
                ps.push({id:'cpu_'+i, name:n, human:false, cpu:true});
            }
            
            // Reset and fetch analytics
            resetAnalytics();
            fetchPlayerWins(ps.map(p => p.name));
            
            initGame(ps);
            showScreen('game-screen');
            render();
            if (G.players[0].cpu) setTimeout(cpuTurn, 1000);
        }

        function restartContract() {
            // Only available offline/tutorial
            if (L.isOnline) return toast('Restart only available offline');
            const players = G.players.map(p => ({id:p.id, name:p.name, human:p.human, cpu:p.cpu, score:p.score}));
            initGame(players);
            render();
            toast('Contract restarted');
        }

        // Tutorial mode (guided first contract)
        function startTutorial() {
            modal('Choose Tutorial', '<p>Select a tutorial focus:</p>', [
                {text:'Basic (sets/discard)', cls:'btn-primary', fn:() => beginTutorial('basic')},
                {text:'Advanced (buy discard, K-A run)', cls:'btn-secondary', fn:() => beginTutorial('advanced')},
                {text:'Cancel', cls:'btn-secondary'}
            ]);
        }

        function beginTutorial(level) {
            L.tutorial = true;
            tutorialLevel = level;
            tutorialSteps = level === 'advanced' ? TUTORIAL_ADV : TUTORIAL_BASIC;
            gameMode = 'tutorial';
            CONTRACTS = level === 'advanced'
                ? [{id:1, sets:0, runs:1, cards:7, desc:'Run (Tutorial)'}]
                : [{id:1, sets:2, runs:0, cards:7, desc:'Sets (Tutorial)'}];
            resetAnalytics();
            
            const you = {id:'human', name:'You', human:true, cpu:false, hand:[], score:0, laid:false};
            const cpu = {id:'cpu_1', name:'Coach Bot', human:false, cpu:true, hand:[], score:0, laid:false};
            
            if (level === 'advanced') {
                // Run tutorial: buy discard (J‚ô•) and make 10-J-Q-K-A‚ô•
                you.hand = [
                    makeCard('hearts','10'), makeCard('hearts','Q'), makeCard('hearts','K'),
                    makeCard('hearts','A'), makeCard('clubs','2'), makeCard('spades','7'),
                    makeCard('diamonds','4')
                ];
                cpu.hand = [
                    makeCard('spades','2'), makeCard('clubs','7'), makeCard('hearts','8'),
                    makeCard('diamonds','9'), makeCard('spades','10'), makeCard('clubs','4'),
                    makeCard('hearts','Q')
                ];
                G = {
                    players: [you, cpu],
                    deck: [
                        makeCard('spades','J'), makeCard('clubs','6'), makeCard('diamonds','9'),
                        makeCard('clubs','8'), makeCard('hearts','4')
                    ],
                    discard: [makeCard('hearts','J')],
                    melds: [],
                    cur: 0,
                    contract: 0,
                    phase: 'draw',
                    drawn: false,
                    buyQ: [],
                    buyer: -1,
                    started: true,
                    hostId: L.myId,
                    difficulty: 'easy',
                    deadCards: []
                };
            } else {
                // Basic tutorial: two sets and a discard
                you.hand = [
                    makeCard('hearts','3'), makeCard('clubs','3'), makeCard('diamonds','3'),
                    makeCard('hearts','5'), makeCard('clubs','5'), makeCard('diamonds','5'),
                    makeCard('spades','9')
                ];
                cpu.hand = [
                    makeCard('spades','2'), makeCard('clubs','7'), makeCard('hearts','8'),
                    makeCard('diamonds','9'), makeCard('spades','10'), makeCard('clubs','4'),
                    makeCard('hearts','Q')
                ];
                G = {
                    players: [you, cpu],
                    deck: [
                        makeCard('spades','J'), makeCard('clubs','6'), makeCard('diamonds','A'),
                        makeCard('spades','4'), makeCard('diamonds','6'), makeCard('clubs','8')
                    ],
                    discard: [makeCard('hearts','K')],
                    melds: [],
                    cur: 0,
                    contract: 0,
                    phase: 'draw',
                    drawn: false,
                    buyQ: [],
                    buyer: -1,
                    started: true,
                    hostId: L.myId,
                    difficulty: 'easy',
                    deadCards: []
                };
            }
            
            L.isHost = true;
            L.isOnline = false;
            L.myId = 'human';
            L.myName = 'You';
            L.diff = 'easy';
            L.sel = [];
            tutorialStep = null;
            setTutorialStep(tutorialSteps[0].id);
            showScreen('game-screen');
            render();
        }

        function exitTutorial() {
            if (!L.tutorial) return;
            L.tutorial = false;
            tutorialStep = null;
            hideTutorialTip();
            showScreen('title-screen');
        }

        function setTutorialStep(id) {
            tutorialStep = id;
            const step = tutorialSteps.find(s => s.id === id);
            const tip = document.getElementById('tutorial-tip');
            const textEl = document.getElementById('tutorial-text');
            if (!tip || !textEl) return;
            if (!step) { tip.classList.remove('active'); return; }
            textEl.textContent = step.text;
            tip.classList.add('active');
        }

        function hideTutorialTip() {
            const tip = document.getElementById('tutorial-tip');
            if (tip) tip.classList.remove('active');
        }

        function advanceTutorial(event) {
            if (!L.tutorial) return;
            const idx = tutorialSteps.findIndex(s => s.id === tutorialStep);
            const step = tutorialSteps[idx];
            if (!step) return;
            // Custom selection triggers
            if (event === 'selected-basic' && tutorialLevel === 'basic' && tutorialStep === 'select') {
                setTutorialStep('lay');
                return;
            }
            if (event === 'selected-adv' && tutorialLevel === 'advanced' && tutorialStep === 'select-run') {
                setTutorialStep('lay');
                return;
            }
            if (step.trigger && step.trigger !== event) return;
            const next = tutorialSteps[idx + 1];
            if (next) {
                setTutorialStep(next.id);
            } else {
                setTutorialStep('done');
                modal('Tutorial Complete', `<p>${tutorialLevel === 'advanced' ? 'Great! You bought a discard and made a high-A run.' : 'Great job! You drew, laid two sets, and discarded.'}</p><p>Start a real game from the menu.</p>`, [
                    {text:'Back to Menu', cls:'btn-primary', fn: exitTutorial},
                    {text:'Replay Tutorial', cls:'btn-secondary', fn: startTutorial}
                ]);
            }
        }

        // Quick start solo using current selections (fallback to defaults)
        function quickStartSolo() {
            const nameEl = document.getElementById('solo-name');
            nameEl.value = nameEl.value.trim() || 'You';
            
            // Ensure we have a selected player count
            let playerBtn = document.querySelector('#solo-player-grid .selected');
            if (!playerBtn) {
                playerBtn = document.querySelector('#solo-player-grid [data-val="3"]');
                playerBtn?.classList.add('selected');
            }
            
            // Ensure we have a selected difficulty
            let diffBtn = document.querySelector('#diff-grid .selected');
            if (!diffBtn) {
                diffBtn = document.querySelector('#diff-grid [data-val="easy"]');
                diffBtn?.classList.add('selected');
            }
            
            startSoloGame();
        }

        // Init Game
        function initGame(ps) {
            const c = CONTRACTS[0];
            G = {
                players: ps.map(p => ({...p, hand:[], score:0, laid:false})),
                deck: makeDeck(numDecks(ps.length)),
                discard: [],
                melds: [],
                cur: 0,
                contract: 0,
                phase: 'draw',
                drawn: false,
                buyQ: [],
                buyer: -1,
                started: true,
                hostId: L.myId,
                difficulty: L.diff || 'easy',
                deadCards: []
            };
            console.log('Dealing', c.cards, 'cards to', G.players.length, 'players');
            console.log('Deck size before deal:', G.deck.length);
            for (let i = 0; i < c.cards; i++) {
                G.players.forEach(p => {
                    if (G.deck.length > 0) {
                        p.hand.push(G.deck.pop());
                    }
                });
            }
            G.discard.push(G.deck.pop());
            console.log('After deal - Player hands:', G.players.map(p => p.hand.length));
            console.log('Deck size after deal:', G.deck.length);
        }

        // Render
        function render() {
            const me = getMe();
            console.log('Render - My ID:', L.myId, 'Found player:', me?.name, 'Hand size:', me?.hand?.length);
            const c = CONTRACTS[G.contract];
            document.getElementById('c-num').textContent = c.id;
            document.getElementById('c-total').textContent = CONTRACTS.length;
            document.getElementById('c-desc').textContent = c.desc;
            document.getElementById('deck-num').textContent = G.deck.length;
            document.getElementById('deck-lbl').textContent = G.deck.length;
            document.getElementById('my-score').textContent = me.score;
            
            // Update player wins badge
            const myWins = analytics.playerWins[me.name] || 0;
            const winsBadge = document.getElementById('my-wins-badge');
            if (myWins > 0) {
                winsBadge.textContent = myWins + 'üèÜ';
                winsBadge.style.display = 'inline';
            } else {
                winsBadge.style.display = 'none';
            }
            
            // Update player win probability
            const myProb = calculateWinProbability(me, G.players);
            const probEl = document.getElementById('my-prob');
            const probClass = myProb >= 50 ? 'prob-high' : myProb >= 25 ? 'prob-med' : 'prob-low';
            probEl.className = probClass;
            probEl.textContent = myProb + '% win';

            const ti = document.getElementById('turn-ind');
            const buyBanner = document.getElementById('buy-banner');
            const buyWaiting = document.getElementById('buy-waiting');
            const nextNotice = document.getElementById('next-player-notice');
            
            // Hide all banners first
            buyBanner.classList.remove('active');
            buyWaiting.classList.remove('active');
            nextNotice.classList.remove('active');
            
            // Check if I'm the next player (would take discard on my turn, no buy needed)
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const imNextPlayer = G.players[nextPlayerIdx]?.id === L.myId;
            
            if (G.phase === 'buying' && amBuying()) {
                // It's my turn to decide on buying
                const position = G.players.findIndex(p => p.id === L.myId);
                const isFirst = position === nextPlayerIdx;
                ti.textContent = isFirst ? 'üõí First dibs! Buy this card?' : 'üõí Your turn to buy!';
                ti.className = 'turn-indicator your-turn';
                showBuyBanner();
            } else if (G.phase === 'buying') {
                // Someone else is deciding
                ti.textContent = '‚è≥ ' + (G.players[G.buyer]?.name || '') + ' deciding...';
                ti.className = 'turn-indicator waiting';
                const buyer = G.players[G.buyer];
                const buyerIsNext = G.buyer === nextPlayerIdx;
                document.getElementById('buy-waiting-title').textContent = `‚è≥ ${buyer?.name || 'Someone'} is deciding...`;
                document.getElementById('buy-waiting-detail').textContent = buyerIsNext 
                    ? `They have first dibs on the discarded card`
                    : `Waiting for buy decision (+1 penalty card to buy)`;
                buyWaiting.classList.add('active');
            } else if (myTurn()) {
                ti.textContent = G.drawn ? 'üé¥ Play cards or select 1 to discard' : 'üëÜ Tap DRAW or DISCARD pile to draw';
                ti.className = 'turn-indicator your-turn';
            } else {
                ti.textContent = '‚è≥ ' + (G.players[G.cur]?.name || '') + "'s turn";
                ti.className = 'turn-indicator waiting';
            }
            
            const cpuStatusEl = document.getElementById('cpu-status');
            if (cpuStatusEl) {
                let cpuText = '';
                if (G.phase === 'buying' && G.players[G.buyer]?.cpu && !amBuying()) {
                    cpuText = `${G.players[G.buyer].name} is deciding...`;
                } else if (G.players[G.cur]?.cpu) {
                    cpuText = G.drawn ? `${G.players[G.cur].name} is playing...` : `${G.players[G.cur].name} is drawing...`;
                }
                cpuStatusEl.textContent = cpuText;
                cpuStatusEl.className = 'cpu-status' + (cpuText ? ' active' : '');
            }

            document.getElementById('opp-row').innerHTML = G.players.map((p, i) => {
                if (p.id === L.myId) return '';
                const act = i === G.cur && G.phase !== 'buying';
                const buying = G.phase === 'buying' && i === G.buyer;
                const wins = analytics.playerWins[p.name] || 0;
                const prob = calculateWinProbability(p, G.players);
                const probClass = prob >= 50 ? 'prob-high' : prob >= 25 ? 'prob-med' : 'prob-low';
                return `<div class="opponent-card ${act ? 'active' : ''} ${buying ? 'buying' : ''}">
                    <div class="opponent-name">${p.cpu ? 'ü§ñ ' : ''}${p.name} ${wins > 0 ? '<span style="font-size:0.7rem;background:var(--success);padding:2px 6px;border-radius:8px;margin-left:4px;">'+wins+'üèÜ</span>' : ''}</div>
                    <div class="opponent-cards">${p.hand.length} cards</div>
                    <div class="opponent-status">Score: ${p.score} ‚Ä¢ <span class="${probClass}">${prob}%</span></div>
                    ${p.laid ? '<div class="laid-badge">‚úì Laid</div>' : ''}
                    ${buying ? '<div class="laid-badge" style="background:var(--warning);color:#000;">Buying...</div>' : ''}
                </div>`;
            }).join('');

            const dt = document.getElementById('discard-top');
            if (G.discard.length) {
                const top = G.discard[G.discard.length - 1];
                const topIsDead = isDeadCard(top);
                const deadOverlay = topIsDead ? '<div class="card-dead-overlay">üíÄ</div>' : '';
                const deadClass = topIsDead ? ' dead-card' : '';
                
                // Custom Joker on discard
                if (top.rank === 'JOKER') {
                    dt.className = 'card card-front card-appear wild' + (CUSTOM_CARDS.jokerData ? ' joker-custom' : '') + deadClass;
                    dt.style.backgroundImage = CUSTOM_CARDS.jokerData ? `url('${CUSTOM_CARDS.jokerData}')` : '';
                    dt.innerHTML = deadOverlay + '<span class="card-rank">J</span><span class="card-suit">üÉè</span>';
                }
                // Custom Queen on discard
                else if (top.rank === 'Q') {
                    dt.className = 'card card-front card-appear ' + top.suit + (CUSTOM_CARDS.queenData ? ' queen-custom' : '') + deadClass;
                    dt.style.backgroundImage = CUSTOM_CARDS.queenData ? `url('${CUSTOM_CARDS.queenData}')` : '';
                    dt.innerHTML = deadOverlay + `<span class="card-rank">Q</span><span class="card-suit">${SUIT_SYM[top.suit]}</span>`;
                }
                // Regular cards
                else {
                    dt.className = 'card card-front card-appear ' + (top.wild ? 'wild' : top.suit) + deadClass;
                    dt.style.backgroundImage = '';
                    dt.innerHTML = deadOverlay + `<span class="card-rank">${top.rank}</span><span class="card-suit">${SUIT_SYM[top.suit]}</span>`;
                }
            } else {
                dt.className = 'card card-front';
                dt.style.backgroundImage = '';
                dt.innerHTML = '';
            }

            const mb = document.getElementById('melds-box');
            if (!G.melds.length) {
                mb.innerHTML = '<span style="color:var(--text-muted);font-size:0.9rem;">None yet</span>';
            } else {
                mb.innerHTML = G.melds.map(m => `
                    <div class="meld-group">
                        <div class="meld-label">${m.owner}'s ${m.type}</div>
                        <div class="meld-cards">${m.cards.map(cardHtml).join('')}</div>
                    </div>
                `).join('');
            }

            document.getElementById('hand-box').innerHTML = me.hand.map((c, i) => cardHtml(c, i, true)).join('');
            document.getElementById('hand-num').textContent = me.hand.length;
            updateBtns();
        }

        // Custom card images (base64 encoded)
        const CUSTOM_CARDS = {
            joker: 'joker.jpeg',  // Will be set by loadCustomImages
            queen: 'queen.jpeg'   // Will be set by loadCustomImages
        };

        // Sound effects (small synthesized tones)
        const SFX = {
            enabled: localStorage.getItem('sfxEnabled') !== 'false',
            unlocked: false,
            ctx: null,
            defs: {
                draw:   {freq: 340, to: 280, dur: 0.14, type: 'triangle', vol: 0.08},
                discard:{freq: 190, to: 140, dur: 0.15, type: 'sawtooth', vol: 0.08},
                lay:    {freq: 520, to: 680, dur: 0.2,  type: 'square',   vol: 0.1 },
                add:    {freq: 430, to: 560, dur: 0.18, type: 'triangle', vol: 0.08},
                win:    {freq: 620, to: 900, dur: 0.4,  type: 'square',   vol: 0.12}
            }
        };
        
        function getAudioCtx() {
            if (!SFX.enabled) return null;
            if (!SFX.ctx) {
                const AC = window.AudioContext || window.webkitAudioContext;
                if (!AC) return null;
                SFX.ctx = new AC();
            }
            if (SFX.ctx.state === 'suspended') SFX.ctx.resume();
            return SFX.ctx;
        }
        
        function unlockAudio() {
            if (SFX.unlocked) return;
            SFX.unlocked = true;
            const ctx = getAudioCtx();
            if (ctx && ctx.state === 'suspended') ctx.resume();
        }
        
        function playSound(name) {
            if (!SFX.enabled || !SFX.unlocked) return;
            const def = SFX.defs[name];
            const ctx = getAudioCtx();
            if (!ctx || !def) return;
            const now = ctx.currentTime;
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();
            osc.type = def.type || 'sine';
            osc.frequency.setValueAtTime(def.freq, now);
            if (def.to) osc.frequency.linearRampToValueAtTime(def.to, now + def.dur * 0.9);
            gain.gain.setValueAtTime(0.0001, now);
            gain.gain.linearRampToValueAtTime(def.vol || 0.08, now + 0.01);
            gain.gain.exponentialRampToValueAtTime(0.0001, now + def.dur);
            osc.connect(gain).connect(ctx.destination);
            osc.start(now);
            osc.stop(now + def.dur + 0.05);
        }
        
        function toggleSound() {
            SFX.enabled = !SFX.enabled;
            localStorage.setItem('sfxEnabled', SFX.enabled);
            updateSoundToggle();
            if (SFX.enabled) {
                unlockAudio();
                playSound('draw');
            }
        }
        
        function updateSoundToggle() {
            const btn = document.getElementById('sound-toggle');
            if (!btn) return;
            btn.textContent = SFX.enabled ? 'üîä' : 'üîá';
            btn.title = SFX.enabled ? 'Sound on' : 'Sound off';
        }
        
        // Check if a card is "dead" (buried in discard pile, not the top card)
        function isDeadCard(c) {
            if (!G.deadCards || !G.deadCards.length) return false;
            // Use unique card ID if available, otherwise fall back to rank/suit (for old saves)
            if (c.id !== undefined) {
                return G.deadCards.some(d => d.id === c.id);
            }
            return G.deadCards.some(d => d.rank === c.rank && d.suit === c.suit && d.wild === c.wild);
        }

        function cardHtml(c, idx = null, hand = false) {
            const sel = idx !== null && L.sel.includes(idx) ? 'selected' : '';
            const isDead = isDeadCard(c);
            const deadClass = isDead ? 'dead-card' : '';
            const click = ''; // click handled via pointer for reliability
            const drag = hand && idx !== null && !IS_TOUCH ? `draggable="true" data-idx="${idx}"` : '';
            const deadOverlay = isDead ? '<div class="card-dead-overlay">üíÄ</div>' : '';
            
            // Custom Joker card
            if (c.rank === 'JOKER') {
                const style = CUSTOM_CARDS.jokerData ? `style="background-image: url('${CUSTOM_CARDS.jokerData}')"` : '';
                const cls = CUSTOM_CARDS.jokerData ? 'wild joker-custom' : 'wild';
                return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${style} ${drag} onpointerdown="cardPointer(event, ${idx})">
                    ${deadOverlay}
                    <span class="card-rank">J</span>
                    <span class="card-suit">üÉè</span>
                </div>`;
            }
            
            // Custom Queen card
            if (c.rank === 'Q') {
                const style = CUSTOM_CARDS.queenData ? `style="background-image: url('${CUSTOM_CARDS.queenData}')"` : '';
                const cls = CUSTOM_CARDS.queenData ? `${c.suit} queen-custom` : c.suit;
                return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${style} ${drag} onpointerdown="cardPointer(event, ${idx})">
                    ${deadOverlay}
                    <span class="card-rank">Q</span>
                    <span class="card-suit">${SUIT_SYM[c.suit]}</span>
                </div>`;
            }
            
            // Regular cards
            const cls = c.wild ? 'wild' : c.suit;
            const cnt = `${deadOverlay}<span class="card-rank">${c.rank}</span><span class="card-suit">${SUIT_SYM[c.suit]}</span>`;
            return `<div class="card card-front card-appear ${cls} ${sel} ${deadClass}" ${drag} onpointerdown="cardPointer(event, ${idx})">${cnt}</div>`;
        }

        function updateBtns() {
            const me = getMe();
            const turn = myTurn();
            const drawn = G.drawn;
            const buying = G.phase === 'buying';
            document.getElementById('btn-lay').disabled = !(turn && drawn && !me.laid && L.sel.length > 0 && !buying);
            document.getElementById('btn-add').disabled = !(turn && drawn && me.laid && G.melds.length && L.sel.length && !buying);
            document.getElementById('btn-disc').disabled = !(turn && drawn && L.sel.length === 1 && !buying);
            
            // Update move buttons - only enabled if exactly 1 card selected
            const moveLeft = document.getElementById('btn-move-left');
            const moveRight = document.getElementById('btn-move-right');
            if (moveLeft && moveRight) {
                moveLeft.disabled = L.sel.length !== 1 || L.sel[0] === 0;
                moveRight.disabled = L.sel.length !== 1 || L.sel[0] >= me.hand.length - 1;
            }
            updateSelectionBadge();
        }

        // Helpers
        function getMe() { return G.players.find(p => p.id === L.myId) || G.players[0]; }
        function myIdx() { return G.players.findIndex(p => p.id === L.myId); }
        function myTurn() { return G.players[G.cur]?.id === L.myId; }
        function amBuying() { return G.buyer >= 0 && G.players[G.buyer]?.id === L.myId; }
        function isFinalContract() { return G.contract === CONTRACTS.length - 1; }
        function isLastContract() { return G.contract >= CONTRACTS.length - 1; }

        // Card Selection
        function toggleCard(i) {
            if (G.phase === 'buying') return toast('Wait for buying');
            if (!myTurn()) return toast('Not your turn');
            if (!G.drawn) return toast('Draw first');
            const x = L.sel.indexOf(i);
            if (x > -1) L.sel.splice(x, 1);
            else L.sel.push(i);
            if (L.tutorial) {
                const needed = tutorialStep === 'select' ? 6 : (tutorialStep === 'select-run' ? 5 : 0);
                if (needed && L.sel.length >= needed) {
                    advanceTutorial(tutorialLevel === 'advanced' ? 'selected-adv' : 'selected-basic');
                }
            }
            updateSelectionBadge();
            render();
        }
        function cardPointer(e, idx) {
            if (!myTurn()) return;
            if (e) {
                e.preventDefault();
                e.stopPropagation();
            }
            toggleCard(idx);
        }

        function clearSelection() {
            L.sel = [];
            updateSelectionBadge();
            render();
        }
        function updateSelectionBadge() {
            const el = document.getElementById('sel-badge');
            if (!el) return;
            const count = L.sel.length;
            el.textContent = count + ' selected';
        }

        let sortMode = 'suit'; // suit | rank
        function toggleSortMode() {
            sortMode = sortMode === 'suit' ? 'rank' : 'suit';
            document.getElementById('sort-mode-btn').textContent = 'Sort: ' + (sortMode === 'suit' ? 'Suit' : 'Rank');
        }
        function toggleWildPos() {
            if (wildPos === 'auto') wildPos = 'front';
            else if (wildPos === 'front') wildPos = 'end';
            else wildPos = 'auto';
            document.getElementById('wild-pos-btn').textContent = 'Wild: ' + (wildPos.charAt(0).toUpperCase() + wildPos.slice(1));
        }
        function sortHand() {
            const me = getMe();
            me.hand.sort((a, b) => {
                if (a.wild && !b.wild) return 1;
                if (!a.wild && b.wild) return -1;
                if (sortMode === 'suit') {
                    if (a.suit !== b.suit) return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
                    return sortVal(a.rank) - sortVal(b.rank);
                } else {
                    if (sortVal(a.rank) !== sortVal(b.rank)) return sortVal(a.rank) - sortVal(b.rank);
                    return SUITS.indexOf(a.suit) - SUITS.indexOf(b.suit);
                }
            });
            L.sel = [];
            updateSelectionBadge();
            sync();
        }
        
        function moveCardLeft() {
            if (L.sel.length !== 1) return toast('Select 1 card to move');
            const me = getMe();
            const idx = L.sel[0];
            if (idx <= 0) return;
            // Swap with card to the left
            [me.hand[idx], me.hand[idx - 1]] = [me.hand[idx - 1], me.hand[idx]];
            L.sel = [idx - 1]; // Keep the same card selected
            updateSelectionBadge();
            sync();
        }
        
        function moveCardRight() {
            if (L.sel.length !== 1) return toast('Select 1 card to move');
            const me = getMe();
            const idx = L.sel[0];
            if (idx >= me.hand.length - 1) return;
            // Swap with card to the right
            [me.hand[idx], me.hand[idx + 1]] = [me.hand[idx + 1], me.hand[idx]];
            L.sel = [idx + 1]; // Keep the same card selected
            updateSelectionBadge();
            sync();
        }

        // Drag and drop for reordering cards
        let draggedIdx = null;
        
        function setupDragDrop() {
            const handBox = document.getElementById('hand-box');
            
            handBox.addEventListener('dragstart', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (!card) return;
                draggedIdx = parseInt(card.dataset.idx);
                card.classList.add('dragging');
                e.dataTransfer.effectAllowed = 'move';
            });
            
            handBox.addEventListener('dragend', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (card) card.classList.remove('dragging');
                document.querySelectorAll('.card.drag-over').forEach(c => c.classList.remove('drag-over'));
                draggedIdx = null;
            });
            
            handBox.addEventListener('dragover', (e) => {
                e.preventDefault();
                const card = e.target.closest('.card[data-idx]');
                if (card && parseInt(card.dataset.idx) !== draggedIdx) {
                    document.querySelectorAll('.card.drag-over').forEach(c => c.classList.remove('drag-over'));
                    card.classList.add('drag-over');
                }
            });
            
            handBox.addEventListener('dragleave', (e) => {
                const card = e.target.closest('.card[data-idx]');
                if (card) card.classList.remove('drag-over');
            });
            
            handBox.addEventListener('drop', (e) => {
                e.preventDefault();
                const card = e.target.closest('.card[data-idx]');
                if (!card || draggedIdx === null) return;
                
                const dropIdx = parseInt(card.dataset.idx);
                if (dropIdx === draggedIdx) return;
                
                const me = getMe();
                const [draggedCard] = me.hand.splice(draggedIdx, 1);
                me.hand.splice(dropIdx, 0, draggedCard);
                L.sel = [];
                render();
            });
            
            // Touch drag disabled; rely on tap + move arrows for more reliable ordering on iOS
        }
        
        // Initialize drag drop when page loads
        document.addEventListener('DOMContentLoaded', () => {
            setupDragDrop();
            updateSoundToggle();
            loadSettings();
            // Unlock audio after first user gesture to avoid autoplay blocking
            window.addEventListener('pointerdown', unlockAudio, {once: true});
            window.addEventListener('keydown', unlockAudio, {once: true});
            registerServiceWorker();
            if (IS_TOUCH) document.body.classList.add('touch');
            initClippy();
            // Expose clippy toggle in modal
            const clippyToggle = document.createElement('button');
            clippyToggle.className = 'btn btn-secondary btn-sm';
            clippyToggle.textContent = 'Toggle Tips';
            clippyToggle.style.marginTop = '10px';
            clippyToggle.onclick = () => {
                const enabled = localStorage.getItem('clippyEnabled') === 'true';
                toggleClippySetting(!enabled);
                toast(enabled ? 'Tips hidden' : 'Tips enabled');
            };
            document.getElementById('title-screen')?.querySelector('.menu-buttons')?.appendChild(clippyToggle);
        });

        // Draw
        function drawDeck() {
            if (!myTurn()) return toast('Not your turn');
            if (G.drawn) return toast('Already drew');
            if (G.phase === 'buying') return;
            reshuffle();
            getMe().hand.push(G.deck.pop());
            G.drawn = true;
            G.phase = 'play';
            playSound('draw');
            advanceTutorial('after-draw');
            sync();
        }

        function drawDiscard() {
            if (!myTurn()) return toast('Not your turn');
            if (G.drawn) return toast('Already drew');
            if (G.phase === 'buying') return;
            if (!G.discard.length) return toast('Empty');
            
            // Check if top card is dead - can't pick it up!
            const topCard = G.discard[G.discard.length - 1];
            if (isDeadCard(topCard)) {
                return toast('üíÄ Dead card! Draw from deck instead');
            }
            
            // Mark all cards below the top as "dead" (buried)
            if (G.discard.length > 1) {
                const buried = G.discard.slice(0, -1); // All except top card
                G.deadCards = G.deadCards || [];
                buried.forEach(c => {
                    // Only add if not already tracked (use ID)
                    if (!G.deadCards.some(d => d.id === c.id)) {
                        G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild});
                    }
                });
            }
            
            getMe().hand.push(G.discard.pop());
            G.drawn = true;
            G.phase = 'play';
            playSound('draw');
            advanceTutorial('after-draw');
            sync();
        }

        function reshuffle() {
            if (!G.deck.length && G.discard.length > 1) {
                const top = G.discard.pop();
                G.deck = shuffle(G.discard);
                G.discard = [top];
                toast('Reshuffled');
            }
        }

        // Discard
        function doDiscard() {
            if (!myTurn()) return toast('Not your turn');
            if (!G.drawn) return toast('Draw first');
            if (L.sel.length !== 1) return toast('Select 1 card');
            
            const me = getMe();
            const card = me.hand[L.sel[0]];
            
            // Final contract (3 runs): Can only discard if you've laid down AND the card is natural (not wild)
            if (isFinalContract() && me.laid && me.hand.length === 1) {
                if (card.wild) {
                    return toast('Final contract: Cannot discard a wild! Use it in your runs.');
                }
                // Natural card - allow discard and win
            }
            
            G.discard.push(card);
            me.hand.splice(L.sel[0], 1);
            L.sel = [];
            playSound('discard');
            advanceTutorial('discarded');
            
            // Check if player went out (must have laid down AND have 0 cards)
            if (!me.hand.length && me.laid) { 
                sync(); 
                endRound(myIdx()); 
                return; 
            }
            
            render();
            setTimeout(startBuying, 300);
        }

        // Buying
        function startBuying() {
            // Check if the top discard is dead - if so, skip buying entirely
            if (G.discard.length > 0) {
                const topCard = G.discard[G.discard.length - 1];
                if (isDeadCard(topCard)) {
                    // Dead card - no one can buy it
                    nextTurn();
                    return;
                }
            }
            
            // Build buy queue: Next player gets first dibs FOR FREE (no penalty)
            // If they pass, others can buy WITH penalty in turn order
            G.buyQ = [];
            
            // First add the next player (they get it free if they want it)
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            G.buyQ.push(nextPlayerIdx);
            
            // Then add everyone else in turn order (they pay penalty to buy)
            for (let i = 2; i < G.players.length; i++) {
                G.buyQ.push((G.cur + i) % G.players.length);
            }
            
            G.phase = 'buying';
            G.buyer = G.buyQ.shift();
            sync();
            // CPU buying is handled by checkCPUBuying() called from sync()
        }

        function nextBuyer() {
            if (G.buyQ.length) {
                G.buyer = G.buyQ.shift();
                cpuBuyingRunning = false; // Reset so next buyer can be checked
                sync();
            } else {
                G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                nextTurn();
            }
        }

        function showBuyBanner() {
            if (!G.discard.length) return;
            const top = G.discard[G.discard.length - 1];
            const banner = document.getElementById('buy-banner');
            const cardEl = document.getElementById('buy-banner-card');
            
            // Check if current buyer is the next player (gets it free) or someone else (pays penalty)
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const buyerIsNextPlayer = G.buyer === nextPlayerIdx;
            
            // Update banner text based on who's buying
            const titleEl = banner.querySelector('.buy-banner-title');
            const subtitleEl = banner.querySelector('.buy-banner-subtitle');
            const buyBtnEl = banner.querySelector('.buy-btn-yes');
            
            if (buyerIsNextPlayer) {
                titleEl.textContent = 'Take this card?';
                subtitleEl.textContent = "It's your turn - take it FREE!";
                buyBtnEl.textContent = '‚úì Take It';
            } else {
                titleEl.textContent = 'Buy this card?';
                subtitleEl.textContent = "You'll also draw 1 penalty card";
                buyBtnEl.textContent = '‚úì Buy It';
            }
            
            // Custom Joker
            if (top.rank === 'JOKER' && CUSTOM_CARDS.jokerData) {
                cardEl.className = 'buy-banner-card joker-custom';
                cardEl.style.backgroundImage = `url('${CUSTOM_CARDS.jokerData}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center top';
                cardEl.innerHTML = '<span style="font-size:1.5rem;text-shadow:2px 2px 4px rgba(0,0,0,0.8);">J</span>';
            }
            // Custom Queen
            else if (top.rank === 'Q' && CUSTOM_CARDS.queenData) {
                cardEl.className = 'buy-banner-card queen-custom ' + top.suit;
                cardEl.style.backgroundImage = `url('${CUSTOM_CARDS.queenData}')`;
                cardEl.style.backgroundSize = 'cover';
                cardEl.style.backgroundPosition = 'center top';
                cardEl.innerHTML = `<span style="font-size:1.5rem;text-shadow:2px 2px 4px rgba(0,0,0,0.8);">Q</span>`;
            }
            // Regular cards
            else {
                cardEl.className = 'buy-banner-card ' + (top.wild ? 'wild' : top.suit);
                cardEl.style.backgroundImage = '';
                cardEl.innerHTML = top.rank === 'JOKER' 
                    ? 'J<br>üÉè' 
                    : `${top.rank}<br>${SUIT_SYM[top.suit]}`;
            }
            
            banner.classList.add('active');
        }

        function hideBuyBanner() {
            document.getElementById('buy-banner').classList.remove('active');
            document.getElementById('buy-waiting').classList.remove('active');
            document.getElementById('next-player-notice').classList.remove('active');
        }

        function doBuy() {
            if (!amBuying()) return;
            hideBuyBanner();
            const me = getMe();
            const myIdx = G.players.findIndex(p => p.id === L.myId);
            const nextPlayerIdx = (G.cur + 1) % G.players.length;
            const iAmNextPlayer = myIdx === nextPlayerIdx;
            
            // Track buy in analytics
            trackStat('cardsBought', me.name);
            
            // Mark all cards below the top as "dead" (buried)
            if (G.discard.length > 1) {
                const buried = G.discard.slice(0, -1);
                G.deadCards = G.deadCards || [];
                buried.forEach(c => {
                    if (!G.deadCards.some(d => d.id === c.id)) {
                        G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild});
                    }
                });
            }
            
            // Take the discard
            me.hand.push(G.discard.pop());
            
            if (iAmNextPlayer) {
                // Next player takes it FREE - it's now their turn, they already "drew"
                toast('Took the discard!');
                G.cur = myIdx; // It's now this player's turn
                G.drawn = true; // They've already drawn (the discard)
                G.phase = 'play';
                G.buyer = -1;
                G.buyQ = [];
                L.sel = [];
                sync();
            } else {
                // Others pay penalty (+1 card from deck)
                reshuffle();
                if (G.deck.length) me.hand.push(G.deck.pop());
                toast('Bought! +1 penalty card');
                G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                nextTurn();
            }
        }

        function doPass() {
            if (!amBuying()) return;
            hideBuyBanner();
            nextBuyer();
        }

        // Next Turn
        function nextTurn() {
            // Reset CPU flags for next turn
            cpuRunning = false;
            cpuBuyingRunning = false;
            
            G.cur = (G.cur + 1) % G.players.length;
            G.drawn = false;
            G.phase = 'draw';
            G.buyer = -1;
            G.buyQ = [];
            L.sel = [];
            sync();
        }

        // CPU
        let cpuRunning = false;
        
        function checkCPU() {
            if (cpuRunning) return;
            const p = G.players[G.cur];
            if (p?.cpu && G.phase === 'draw' && !G.drawn) {
                cpuRunning = true;
                setTimeout(() => {
                    cpuTurn();
                    // Don't reset cpuRunning here - cpuTurn will handle flow
                }, 1000);
            }
        }
        
        let cpuBuyingRunning = false;
        
        function checkCPUBuying() {
            if (G.phase !== 'buying') return;
            if (cpuBuyingRunning) return;
            const p = G.players[G.buyer];
            if (p?.cpu) {
                cpuBuyingRunning = true;
                setTimeout(() => {
                    const top = G.discard[G.discard.length - 1];
                    const diff = G.difficulty || 'easy';
                    const nextPlayerIdx = (G.cur + 1) % G.players.length;
                    const isNextPlayer = G.buyer === nextPlayerIdx;
                    
                    // Next player is more likely to take (it's free!)
                    // Others have lower chance since they pay penalty
                    let shouldTake = false;
                    if (isNextPlayer) {
                        // Free card - higher chance to take
                        const takeChance = diff === 'hard' ? 0.7 : diff === 'medium' ? 0.5 : 0.3;
                        shouldTake = top?.wild || Math.random() < takeChance;
                    } else {
                        // Pay penalty - lower chance
                        const buyChance = diff === 'hard' ? 0.4 : diff === 'medium' ? 0.3 : 0.15;
                        shouldTake = top?.wild || Math.random() < buyChance;
                    }
                    
                    if (shouldTake) {
                        // Mark buried cards as dead
                        if (G.discard.length > 1) {
                            const buried = G.discard.slice(0, -1);
                            G.deadCards = G.deadCards || [];
                            buried.forEach(c => {
                                if (!G.deadCards.some(d => d.id === c.id)) {
                                    G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild});
                                }
                            });
                        }
                        
                        p.hand.push(G.discard.pop());
                        
                        if (isNextPlayer) {
                            // Free take - it's now their turn
                            toast(p.name + ' took the discard!');
                            G.cur = G.buyer;
                            G.drawn = true;
                            G.phase = 'play';
                            G.buyer = -1;
                            G.buyQ = [];
                            cpuBuyingRunning = false;
                            sync();
                            // Continue CPU turn since they already drew
                            setTimeout(() => {
                                cpuBuyingRunning = false;
                                cpuRunning = false;
                                cpuPlayPhase(p);
                            }, 800);
                        } else {
                            // Paid buy - draw penalty card, then next turn
                            reshuffle();
                            if (G.deck.length) p.hand.push(G.deck.pop());
                            toast(p.name + ' bought! +1 penalty');
                            G.phase = 'draw'; G.buyer = -1; G.buyQ = [];
                            cpuBuyingRunning = false;
                            sync();
                            nextTurn();
                        }
                    } else {
                        cpuBuyingRunning = false;
                        nextBuyer();
                    }
                }, 800);
            }
        }
        
        // CPU play phase (after drawing)
        function cpuPlayPhase(p) {
            const diff = G.difficulty || 'easy';
            
            // Try to lay down
            if (!p.laid) {
                const tryLay = diff === 'hard' || diff === 'medium' || Math.random() < 0.3;
                if (tryLay) {
                    const contract = CONTRACTS[G.contract];
                    const result = detectMelds(p.hand, contract);
                    if (result) {
                        result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:p.name, oid:p.id}));
                        result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:p.name, oid:p.id}));
                        const usedCards = [...result.sets.flat(), ...result.runs.flat()];
                        p.hand = p.hand.filter(c => !usedCards.includes(c));
                        p.laid = true;
                        toast(p.name + ' laid down!');
                        sync();
                        
                        if (isFinalContract() && !p.hand.length) {
                            endRound(G.cur);
                            return;
                        }
                    }
                }
            }
            
            // Try to add to melds
            if (p.laid && G.melds.length && (diff === 'medium' || diff === 'hard')) {
                for (let i = p.hand.length - 1; i >= 0; i--) {
                    const card = p.hand[i];
                    for (const m of G.melds) {
                        const testCards = [...m.cards, card];
                        const valid = m.type === 'Set' ? validSet(testCards) : validRun(testCards);
                        if (valid) {
                            m.cards.push(card);
                            if (m.type === 'Run') m.cards.sort((a,b) => a.wild ? 1 : b.wild ? -1 : RANK_VAL[a.rank] - RANK_VAL[b.rank]);
                            p.hand.splice(i, 1);
                            toast(p.name + ' added to ' + m.type.toLowerCase());
                            sync();
                            
                            if (isFinalContract() && !p.hand.length && p.laid) {
                                endRound(G.cur);
                                return;
                            }
                            break;
                        }
                    }
                }
            }
            
            // Discard
            setTimeout(() => {
                if (!p.hand.length) {
                    endRound(G.cur);
                    return;
                }
                
                // Contract 7 check
                if (isFinalContract() && p.laid && p.hand.length === 1 && p.hand[0].wild) {
                    // Can't discard wild in contract 7, stuck
                    endRound(G.cur);
                    return;
                }
                
                // Pick worst card to discard
                let discIdx = 0;
                if (diff !== 'easy') {
                    const scores = p.hand.map((c, i) => {
                        if (c.wild) return { i, score: -100 };
                        const matchRank = p.hand.filter(x => x.rank === c.rank).length;
                        const matchSuit = p.hand.filter(x => x.suit === c.suit && !x.wild).length;
                        return { i, score: matchRank * 2 + matchSuit };
                    });
                    scores.sort((a, b) => a.score - b.score);
                    discIdx = scores[0].i;
                } else {
                    const nonWilds = p.hand.map((c, i) => ({ c, i })).filter(x => !x.c.wild);
                    if (nonWilds.length) discIdx = nonWilds[Math.floor(Math.random() * nonWilds.length)].i;
                }
                
                G.discard.push(p.hand[discIdx]);
                p.hand.splice(discIdx, 1);
                
                if (!p.hand.length && p.laid) {
                    sync();
                    endRound(G.cur);
                    return;
                }
                
                cpuRunning = false;
                sync();
                setTimeout(startBuying, 300);
            }, 800);
        }

        function cpuTurn() {
            const p = G.players[G.cur];
            if (!p?.cpu) return;
            
            const diff = G.difficulty || 'easy';
            
            // Draw phase - smarter CPUs might take from discard
            const topDiscard = G.discard.length ? G.discard[G.discard.length - 1] : null;
            let takeDiscard = false;
            
            if (topDiscard && diff !== 'easy') {
                if (topDiscard.wild) {
                    takeDiscard = true;
                } else {
                    const matchRank = p.hand.filter(c => c.rank === topDiscard.rank).length;
                    const matchSuit = p.hand.filter(c => c.suit === topDiscard.suit && !c.wild).length;
                    if (diff === 'hard') {
                        takeDiscard = matchRank >= 2 || matchSuit >= 3;
                    } else {
                        takeDiscard = matchRank >= 2;
                    }
                }
            }
            
            if (takeDiscard && G.discard.length) {
                // Mark buried cards as dead
                if (G.discard.length > 1) {
                    const buried = G.discard.slice(0, -1);
                    G.deadCards = G.deadCards || [];
                    buried.forEach(c => {
                        if (!G.deadCards.some(d => d.id === c.id)) {
                            G.deadCards.push({id: c.id, rank: c.rank, suit: c.suit, wild: c.wild});
                        }
                    });
                }
                p.hand.push(G.discard.pop());
                toast(p.name + ' took discard');
            } else {
                reshuffle();
                if (G.deck.length) p.hand.push(G.deck.pop());
            }
            
            G.drawn = true;
            G.phase = 'play';
            sync();
            
            setTimeout(() => {
                // Try to lay down
                if (!p.laid) {
                    const tryLay = diff === 'hard' || diff === 'medium' || Math.random() < 0.3;
                    if (tryLay) {
                        const contract = CONTRACTS[G.contract];
                        const result = detectMelds(p.hand, contract);
                        if (result) {
                            result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:p.name, oid:p.id}));
                            result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:p.name, oid:p.id}));
                            const usedCards = [...result.sets.flat(), ...result.runs.flat()];
                            p.hand = p.hand.filter(c => !usedCards.includes(c));
                            p.laid = true;
                            toast(p.name + ' laid down!');
                            sync();
                            
                            if (isFinalContract() && !p.hand.length) {
                                endRound(G.cur);
                                return;
                            }
                        }
                    }
                }
                
                // Try to add to melds (medium/hard)
                if (p.laid && G.melds.length && (diff === 'medium' || diff === 'hard')) {
                    for (let i = p.hand.length - 1; i >= 0; i--) {
                        const card = p.hand[i];
                        for (const m of G.melds) {
                            if (canAdd([card], m)) {
                                m.cards.push(card);
                                p.hand.splice(i, 1);
                                break;
                            }
                        }
                    }
                    if (!p.hand.length && p.laid) {
                        sync();
                        endRound(G.cur);
                        return;
                    }
                }
                
                // Discard
                if (!p.hand.length) {
                    sync();
                    if (p.laid) endRound(G.cur);
                    return;
                }
                
                let idx = 0;
                if (diff === 'easy') {
                    let high = -1;
                    p.hand.forEach((c, i) => {
                        if (!c.wild) {
                            const pts = POINTS[c.rank] || 5;
                            if (pts > high) { high = pts; idx = i; }
                        }
                    });
                } else {
                    let minScore = Infinity;
                    p.hand.forEach((c, i) => {
                        if (c.wild) return;
                        let score = 0;
                        const matchRank = p.hand.filter(x => x.rank === c.rank).length;
                        const matchSuit = p.hand.filter(x => x.suit === c.suit && !x.wild).length;
                        score = matchRank * 10 + matchSuit * 5;
                        if (score < minScore) { minScore = score; idx = i; }
                    });
                }
                
                G.discard.push(p.hand.splice(idx, 1)[0]);
                if (!p.hand.length && p.laid) { sync(); endRound(G.cur); return; }
                render();
                toast(p.name + ' discarded');
                setTimeout(startBuying, 500);
            }, 1200);
        }

        // Lay Down
        function layDown() {
            if (!L.sel.length) return toast('Select cards');
            const me = getMe();
            const c = CONTRACTS[G.contract];
            const cards = L.sel.map(i => me.hand[i]);
            const result = detectMelds(cards, c);
            if (!result) return toast('Need ' + c.desc);
            result.sets.forEach(s => G.melds.push({type:'Set', cards:s, owner:me.name, oid:me.id}));
            result.runs.forEach(r => G.melds.push({type:'Run', cards:r, owner:me.name, oid:me.id}));
            [...L.sel].sort((a,b)=>b-a).forEach(i => me.hand.splice(i, 1));
            me.laid = true;
            L.sel = [];
            toast('Laid down!');
            playSound('lay');
            advanceTutorial('laid');
            
            // Contract 7: no discard, win immediately if all cards used
            if (isFinalContract() && !me.hand.length) { 
                sync(); 
                endRound(myIdx()); 
                return; 
            }
            
            // Other contracts: if you have 0 cards after laying down, you win (no discard needed if empty)
            // But normally you still have cards and need to discard
            if (!me.hand.length) {
                sync();
                endRound(myIdx());
                return;
            }
            
            sync();
        }

        function detectMelds(cards, contract) {
            const res = {sets:[], runs:[]};
            let rem = [...cards];
            
            // Helper to check if two cards are the same (by value, not reference)
            const sameCard = (a, b) => a.rank === b.rank && a.suit === b.suit && a.wild === b.wild;
            
            // Helper to remove used cards from remaining
            const removeUsed = (remaining, used) => {
                const usedCopy = [...used];
                return remaining.filter(c => {
                    const idx = usedCopy.findIndex(u => sameCard(c, u));
                    if (idx >= 0) {
                        usedCopy.splice(idx, 1);
                        return false;
                    }
                    return true;
                });
            };
            
            for (let i = 0; i < contract.runs; i++) {
                const run = findRun(rem);
                if (!run) return null;
                res.runs.push(run);
                rem = removeUsed(rem, run);
            }
            for (let i = 0; i < contract.sets; i++) {
                const set = findSet(rem);
                if (!set) return null;
                res.sets.push(set);
                rem = removeUsed(rem, set);
            }
            
            // Final contract (3 runs): Must use all cards OR have exactly 1 natural card left to discard
            const isFinal = contract.runs === 3 && contract.sets === 0;
            if (isFinal) {
                if (rem.length === 0) {
                    // All cards used - valid
                } else if (rem.length === 1 && !rem[0].wild) {
                    // One natural card left for discard - valid
                } else {
                    // Either too many cards left, or remaining card is wild
                    return null;
                }
            }
            return res;
        }

        function findSet(cards) {
            const wilds = cards.filter(c => c.wild);
            const byRank = {};
            cards.filter(c => !c.wild).forEach(c => {
                if (!byRank[c.rank]) byRank[c.rank] = [];
                byRank[c.rank].push(c);
            });
            const ranks = Object.keys(byRank).sort((a,b) => byRank[b].length - byRank[a].length);
            for (const r of ranks) {
                const nat = byRank[r];
                if (nat.length >= 3) return nat.slice(0, Math.min(4, nat.length));
                if (nat.length >= 1) {
                    const need = 3 - nat.length;
                    if (need <= wilds.length) return [...nat, ...wilds.slice(0, need)];
                }
            }
            return null;
        }

        function findRun(cards) {
            const wilds = cards.filter(c => c.wild);
            const bySuit = {};
            cards.filter(c => !c.wild).forEach(c => {
                if (!bySuit[c.suit]) bySuit[c.suit] = [];
                bySuit[c.suit].push(c);
            });

            const attempt = (aceHigh) => {
                for (const suit of SUITS) {
                    // Need at least 1 natural card in this suit (can fill rest with wilds)
                    if (!bySuit[suit] || bySuit[suit].length < 1) continue;
                    const sc = bySuit[suit].sort((a,b) => runVal(a.rank, aceHigh) - runVal(b.rank, aceHigh));
                    
                    // Try starting from each natural card
                    for (let st = 0; st < sc.length; st++) {
                        let run = [sc[st]];
                        let aw = [...wilds];
                        let lastVal = runVal(sc[st].rank, aceHigh);
                        
                        // Try to extend forward through remaining cards
                        for (let j = st + 1; j < sc.length; j++) {
                            const nextVal = runVal(sc[j].rank, aceHigh);
                            const gap = nextVal - lastVal - 1;
                            
                            if (gap === 0) {
                                // Consecutive - just add it
                                run.push(sc[j]);
                                lastVal = nextVal;
                            } else if (gap > 0 && gap <= aw.length) {
                                // Fill gap with wilds
                                for (let g = 0; g < gap; g++) run.push(aw.shift());
                                run.push(sc[j]);
                                lastVal = nextVal;
                            } else if (gap < 0) {
                                // Duplicate rank - skip
                                continue;
                            } else {
                                // Gap too big - stop extending
                                break;
                            }
                        }
                        
                        // Can we extend with wilds at the end?
                        const maxVal = aceHigh ? 14 : 13;
                        while (run.length < 4 && aw.length > 0 && lastVal < maxVal) {
                            run.push(aw.shift());
                            lastVal++;
                        }
                        
                        // Can we extend with wilds at the beginning?
                        let firstVal = runVal(sc[st].rank, aceHigh);
                        while (run.length < 4 && aw.length > 0 && firstVal > 1) {
                            run.unshift(aw.shift());
                            firstVal--;
                        }
                        
                        const naturals = run.filter(x => !x.wild).length;
                        if (run.length >= 4 && naturals >= 3) return adjustRunOrder(run);
                    }
                }
                return null;
            };
            
            return attempt(false) || attempt(true);
        }

        // Add to Meld
        function showAddModal() {
            if (!L.sel.length) return toast('Select cards');
            const me = getMe();
            const cards = L.sel.map(i => me.hand[i]);
            let html = '<p style="margin-bottom:15px;">Select a set or run:</p>';
            G.melds.forEach((m, i) => {
                const ok = canAdd(cards, m);
                html += `<div class="meld-option ${ok?'':'disabled'}" onclick="${ok?`addTo(${i})`:''}"}>
                    <div class="meld-option-title">${m.owner}'s ${m.type}</div>
                    <div class="meld-option-cards">${m.cards.map(c=>c.rank).join(', ')}</div>
                </div>`;
            });
            modal('Add to Set/Run', html, [{text:'Cancel', cls:'btn-secondary'}]);
        }

        function canAdd(cards, m) {
            const all = [...m.cards, ...cards];
            return m.type === 'Set' ? validSet(all) : validRun(all);
        }

        function validSet(cards) {
            if (cards.length < 3) return false;
            const nat = cards.filter(c => !c.wild);
            if (!nat.length) return false;
            const r = nat[0].rank;
            return nat.every(c => c.rank === r);
        }

        function validRun(cards) {
            if (cards.length < 4) return false;
            const nat = cards.filter(c => !c.wild);
            if (nat.length < 3) return false;
            const suit = nat[0].suit;
            if (!nat.every(c => c.suit === suit)) return false;
            
            const passes = (aceHigh) => {
                const sorted = [...nat].sort((a,b) => runVal(a.rank, aceHigh) - runVal(b.rank, aceHigh));
                const min = runVal(sorted[0].rank, aceHigh);
                const max = runVal(sorted[sorted.length-1].rank, aceHigh);
                if (max - min + 1 > cards.length) return false;
                const ranks = new Set(sorted.map(c => runVal(c.rank, aceHigh)));
                return ranks.size === sorted.length;
            };
            
            return passes(false) || passes(true);
        }

        function addTo(i) {
            closeModal();
            const me = getMe();
            const m = G.melds[i];
            const cards = L.sel.map(x => me.hand[x]);
            if (!canAdd(cards, m)) return toast("Can't add");
            cards.forEach(c => m.cards.push(c));
            if (m.type === 'Run') {
                const nat = m.cards.filter(c => !c.wild).sort((a,b)=>runVal(a.rank,true)-runVal(b.rank,true));
                const wilds = m.cards.filter(c => c.wild);
                m.cards = adjustRunOrder([...nat, ...wilds]);
            }
            [...L.sel].sort((a,b)=>b-a).forEach(x => me.hand.splice(x, 1));
            L.sel = [];
            toast('Added!');
            playSound('add');
            
            // Contract 7 (index 6): win immediately if all cards played into runs
            if (isFinalContract() && !me.hand.length && me.laid) { 
                sync(); 
                endRound(myIdx()); 
                return; 
            }
            
            // Contracts 1-6: Must still discard to end turn
            // If hand is empty somehow, that's a win
            if (!me.hand.length && me.laid) {
                sync();
                endRound(myIdx());
                return;
            }
            
            sync();
        }

        // End Round
        function endRound(wi) {
            if (L.tutorial) return;
            cpuRunning = false;
            cpuBuyingRunning = false;
            const winner = G.players[wi];
            
            // Track round win
            analytics.roundsPlayed++;
            trackStat('roundWins', winner.name);
            playSound('win');
            
            // Calculate points added this round
            const pointsAdded = {};
            G.players.forEach((p, i) => {
                if (i !== wi) {
                    const pts = p.hand.reduce((s, c) => s + (POINTS[c.rank] || 5), 0);
                    p.score += pts;
                    pointsAdded[p.name] = pts;
                } else {
                    pointsAdded[p.name] = 0;
                }
            });
            
            if (isLastContract()) { showFinal(); return; }
            
            // Build round analytics
            const sorted = [...G.players].sort((a,b) => a.score - b.score);
            let analyticsHtml = `
                <div class="analytics-container">
                    <div class="analytics-title">üìä Round ${analytics.roundsPlayed} Summary</div>
                    ${sorted.map((p, i) => {
                        const prob = calculateWinProbability(p, G.players);
                        const probClass = prob >= 50 ? 'prob-high' : prob >= 25 ? 'prob-med' : 'prob-low';
                        const wins = analytics.playerWins[p.name] || 0;
                        const roundWins = analytics.roundWins[p.name] || 0;
                        const isWinner = p.name === winner.name;
                        return `
                            <div class="player-stats-row ${isWinner ? 'winner' : ''}">
                                <div class="player-stats-name">
                                    ${isWinner ? 'üëë ' : ''}${p.name}
                                    ${wins > 0 ? `<span class="player-stats-wins">${wins}üèÜ</span>` : ''}
                                </div>
                                <div>
                                    <span class="player-stats-score">${p.score} pts</span>
                                    <span style="color:${pointsAdded[p.name] > 0 ? 'var(--danger)' : 'var(--success)'};font-size:0.8rem;margin-left:5px;">
                                        ${pointsAdded[p.name] > 0 ? '+' + pointsAdded[p.name] : '‚úì'}
                                    </span>
                                </div>
                                <div class="player-stats-prob ${probClass}">${prob}% win</div>
                            </div>
                        `;
                    }).join('')}
                    <div class="analytics-grid" style="margin-top:15px;">
                        <div class="analytics-stat">
                            <div class="analytics-value">${analytics.roundsPlayed}/${CONTRACTS.length}</div>
                            <div class="analytics-label">Contracts Done</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-value">${analytics.roundWins[winner.name] || 1}</div>
                            <div class="analytics-label">${winner.name}'s Rounds</div>
                        </div>
                    </div>
                </div>
                <p style="margin-top:15px;text-align:center;">Next: <strong>Contract ${G.contract + 2}</strong> - ${CONTRACTS[G.contract + 1].desc}</p>
            `;
            
            modal('üéâ ' + winner.name + ' wins the round!', analyticsHtml, [{text:'Continue', cls:'btn-success', fn:nextContract}]);
        }

        function nextContract() {
            cpuRunning = false;
            cpuBuyingRunning = false;
            G.contract++;
            const c = CONTRACTS[G.contract];
            G.melds = [];
            G.deadCards = []; // Reset dead cards for new contract
            G.players.forEach(p => { p.hand = []; p.laid = false; });
            G.deck = makeDeck(numDecks(G.players.length));
            G.discard = [];
            for (let i = 0; i < c.cards; i++) G.players.forEach(p => p.hand.push(G.deck.pop()));
            G.discard.push(G.deck.pop());
            G.cur = 0; G.drawn = false; G.phase = 'draw'; L.sel = [];
            sync();
            if (G.players[0].cpu) setTimeout(() => { cpuRunning = false; cpuTurn(); }, 1000);
        }

        // Create confetti particles
        function createConfetti() {
            const container = document.getElementById('win-confetti');
            container.innerHTML = '';
            const colors = ['#FFD700', '#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD', '#98D8C8'];
            
            for (let i = 0; i < 100; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + 'vw';
                confetti.style.background = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.width = (Math.random() * 10 + 5) + 'px';
                confetti.style.height = (Math.random() * 10 + 5) + 'px';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                confetti.style.animation = `confettiFall ${Math.random() * 3 + 2}s linear forwards`;
                confetti.style.animationDelay = Math.random() * 2 + 's';
                container.appendChild(confetti);
            }
        }

        function showFinal() {
            const sorted = [...G.players].sort((a,b) => a.score - b.score);
            const winner = sorted[0];
            const isHumanWinner = winner.human && !winner.cpu;
            
            // Track final round win (local only, no leaderboard)
            analytics.roundsPlayed++;
            trackStat('roundWins', winner.name);
            
            // Show epic win animation if human won
            if (isHumanWinner) {
                const overlay = document.getElementById('win-overlay');
                document.getElementById('win-title').textContent = winner.name.toUpperCase() + ' WINS!';
                document.getElementById('win-subtitle').textContent = gameMode === 'quick' ? 'Quick Rummy Champion!' : 'Liverpool Rummy Champion!';
                overlay.classList.add('active');
                createConfetti();
                
                // Play victory sound effect (optional vibration)
                if (navigator.vibrate) navigator.vibrate([100, 50, 100, 50, 200]);
                
                // After animation, show full stats
                setTimeout(() => {
                    overlay.classList.remove('active');
                    showFinalModal(sorted, winner);
                }, 4000);
            } else {
                showFinalModal(sorted, winner);
            }
        }
        
        function showFinalModal(sorted, winner) {
            const totalPoints = sorted.reduce((sum, p) => sum + p.score, 0);
            
            const html = `
                <div class="analytics-container">
                    <div class="analytics-title">üèÅ Final Standings</div>
                    ${sorted.map((p, i) => {
                        const wins = analytics.playerWins[p.name] || 0;
                        const roundWins = analytics.roundWins[p.name] || 0;
                        const isWinner = i === 0;
                        return `
                            <div class="player-stats-row ${isWinner ? 'winner' : ''}">
                                <div class="player-stats-name">
                                    ${isWinner ? 'üèÜ ' : i === 1 ? 'ü•à ' : i === 2 ? 'ü•â ' : (i+1) + '. '}${p.name}
                                    ${wins > 0 ? `<span class="player-stats-wins">${wins}üèÜ</span>` : ''}
                                </div>
                                <div class="player-stats-score">${p.score} pts</div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="analytics-container">
                    <div class="analytics-title">üìä Game Statistics</div>
                    <div class="analytics-grid">
                        <div class="analytics-stat">
                            <div class="analytics-value">${CONTRACTS.length}</div>
                            <div class="analytics-label">Contracts Played</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-value">${totalPoints}</div>
                            <div class="analytics-label">Total Points</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-value">${sorted[0].score}</div>
                            <div class="analytics-label">Winning Score</div>
                        </div>
                        <div class="analytics-stat">
                            <div class="analytics-value">${sorted[sorted.length-1].score - sorted[0].score}</div>
                            <div class="analytics-label">Point Spread</div>
                        </div>
                    </div>
                    
                    <div style="margin-top:15px;">
                        <div class="analytics-title" style="font-size:0.9rem;">üèÖ Rounds Won</div>
                        ${sorted.map(p => {
                            const roundWins = analytics.roundWins[p.name] || 0;
                            const pct = (roundWins / CONTRACTS.length) * 100;
                            return `
                                <div style="margin-bottom:8px;">
                                    <div style="display:flex;justify-content:space-between;font-size:0.85rem;margin-bottom:4px;">
                                        <span>${p.name}</span>
                                        <span>${roundWins}/${CONTRACTS.length}</span>
                                    </div>
                                    <div class="analytics-bar">
                                        <div class="analytics-bar-fill" style="width:${pct}%;background:${p === winner ? 'var(--success)' : 'var(--primary)'};"></div>
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
            
            modal('üéä Game Over!', html, [{text:'Back to Menu', cls:'btn-primary', fn:() => { if (L.isOnline) leaveRoom(); else showScreen('title-screen'); }}]);
        }

        // ==================== LEADERBOARD ====================
        
        const WIN_COOLDOWN_MS = 10000;
        
        // Get or create a unique device ID
        function getDeviceId() {
            let deviceId = localStorage.getItem('deviceId');
            if (!deviceId) {
                deviceId = 'dev_' + Date.now() + '_' + Math.random().toString(36).substring(2, 15);
                localStorage.setItem('deviceId', deviceId);
            }
            return deviceId;
        }
        
        // Leaderboard removed for now
        async function recordWin() { return; }
        async function recordCPUWin() { return; }
        
        function showPinPrompt(safeName, current, ref, deviceId) {
            modal('üîê Enter PIN', `
                <p style="margin-bottom:15px;">This name is protected. Enter the 4-digit PIN:</p>
                <input type="tel" id="pin-input" class="form-input" placeholder="0000" maxlength="4" style="text-align:center;font-size:1.5rem;letter-spacing:10px;">
            `, [
                {text: 'Cancel', cls: 'btn-secondary'},
                {text: 'Submit', cls: 'btn-primary', fn: async () => {
                    const pin = document.getElementById('pin-input').value;
                    if (pin === current.pin) {
                        await ref.set({ 
                            name: safeName, 
                            wins: current.wins + 1,
                            deviceId: deviceId,
                            pin: current.pin
                        });
                        closeModal();
                        toast('üèÜ Win recorded!');
                    } else {
                        toast('‚ùå Wrong PIN');
                    }
                }}
            ]);
            setTimeout(() => document.getElementById('pin-input')?.focus(), 100);
        }
        
        function showSetPinPrompt(safeName, current, ref, deviceId) {
            modal('üîê Claim This Name', `
                <p style="margin-bottom:15px;">Set a 4-digit PIN to protect "${safeName}":</p>
                <input type="tel" id="pin-input" class="form-input" placeholder="0000" maxlength="4" style="text-align:center;font-size:1.5rem;letter-spacing:10px;">
            `, [
                {text: 'Skip', cls: 'btn-secondary', fn: async () => {
                    await ref.set({ 
                        name: safeName, 
                        wins: current.wins + 1,
                        deviceId: deviceId
                    });
                    closeModal();
                    toast('üèÜ Win recorded!');
                }},
                {text: 'Set PIN', cls: 'btn-primary', fn: async () => {
                    const pin = document.getElementById('pin-input').value;
                    if (pin.length === 4 && /^\d+$/.test(pin)) {
                        await ref.set({ 
                            name: safeName, 
                            wins: current.wins + 1,
                            deviceId: deviceId,
                            pin: pin
                        });
                        closeModal();
                        toast('üèÜ Win recorded & PIN set!');
                    } else {
                        toast('PIN must be 4 digits');
                    }
                }}
            ]);
            setTimeout(() => document.getElementById('pin-input')?.focus(), 100);
        }
        
        function showNewPinPrompt(safeName, ref, deviceId) {
            modal('üîê Protect Your Name', `
                <p style="margin-bottom:15px;">Set a 4-digit PIN to protect "${safeName}":</p>
                <input type="tel" id="pin-input" class="form-input" placeholder="0000" maxlength="4" style="text-align:center;font-size:1.5rem;letter-spacing:10px;">
                <p style="margin-top:10px;font-size:0.85rem;color:var(--text-muted);">Required to record wins for this name.</p>
            `, [
                {text: 'Cancel', cls: 'btn-secondary'},
                {text: 'Set PIN', cls: 'btn-primary', fn: async () => {
                    const pin = document.getElementById('pin-input').value;
                    if (pin.length === 4 && /^\d+$/.test(pin)) {
                        await ref.set({ 
                            name: safeName, 
                            wins: 1,
                            deviceId: deviceId,
                            pin: pin
                        });
                        localStorage.setItem('lastWinTs', String(Date.now()));
                        closeModal();
                        toast('üèÜ Win recorded & PIN set!');
                    } else {
                        toast('PIN must be 4 digits');
                    }
                }}
            ]);
            setTimeout(() => document.getElementById('pin-input')?.focus(), 100);
        }

        async function showLeaderboard() {
            modal('Leaderboard Disabled', '<div style="text-align:center;color:var(--text-muted);">Coming soon.</div>', [{text:'Close', cls:'btn-secondary'}]);
        }

        // Rules
        function showRules() {
            modal('How to Play', `
                <div style="text-align:left;font-size:0.9rem;line-height:1.6;">
                    <p><strong>Goal:</strong> Complete all contracts with lowest score.</p><br>
                    
                    <p><strong>üÉè Classic Mode (7 Contracts):</strong></p>
                    <ol style="margin-left:20px;margin-bottom:10px;font-size:0.85rem;">
                        <li>2 Sets</li>
                        <li>1 Set + 1 Run</li>
                        <li>2 Runs</li>
                        <li>3 Sets</li>
                        <li>2 Sets + 1 Run</li>
                        <li>1 Set + 2 Runs</li>
                        <li>3 Runs (all cards)</li>
                    </ol>
                    
                    <p><strong>‚ö° Quick Rummy (4 Contracts):</strong></p>
                    <ol style="margin-left:20px;margin-bottom:15px;font-size:0.85rem;">
                        <li>2 Sets</li>
                        <li>2 Runs</li>
                        <li>3 Sets</li>
                        <li>3 Runs (all cards)</li>
                    </ol>
                    
                    <p><strong>Set:</strong> 3+ same rank (need 1 natural)</p>
                    <p><strong>Run:</strong> 4+ consecutive same suit (need 3 natural)</p><br>
                    <p><strong>Wilds:</strong> All 2s and Jokers</p><br>
                    <p><strong>Taking/Buying Discards:</strong></p>
                    <p style="margin-left:10px;color:var(--text-muted);">When someone discards, the <strong>next player gets first dibs FREE</strong> - they can take it and it becomes their turn (they still discard at end). If they pass, others can <strong>buy</strong> it in turn order (+1 penalty card). If everyone passes, next player's turn begins normally.</p><br>
                    <p><strong>Dead Cards:</strong></p>
                    <p style="margin-left:10px;color:var(--text-muted);">Cards buried in the discard pile are "dead" (üíÄ). Dead cards cannot be picked up or bought.</p>
                </div>
            `, [{text:'Got it!', cls:'btn-primary'}]);
        }
    </script>
</body>
</html>
